using Markov;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using Pathfinding;
using UnityEngine;
//using MathNet.Numerics.Statistics;

public class ShadowSHMM : MonoBehaviour {

    //feature combination
    //represented as: <digits - where digits would be eg. <<unpacked><YKWIM>> with extracting each digit one by one <<through eg. division by 10><YKWIM>>> \ ints \ string
    //with noting of how much space that such would take, and how much that such would improve space ... with noting of other things, such as <<graphics and such><YKWIM>>, vs. readability and\or such
    //as an int: 
    //as a string: [0-2][0-2][0-255][0-7][0-7]
    //with maybe tokens to indicate <<variable><YKWIM>> numbers of digits for a value<< of a feature><YKWIM>>, such as two '|' chars surrounding such <<variable number digits><YKWIM>>, and either hardcoding the <<amounts of ><YKWIM>>the rest of the digits to specific <<amounts><YKWIM>> <<or all of such of said rest of the digits being set to 1><YKWIM>>
    //and then: [0-2][0-1][0-8]
    //as actions and\or such from such data, though such not being part of the feature combination string and\or such but as <<part of a weight<< and\or such><YKWIM>>><YKWIM>> in <<the ><YKWIM>><action probability distribution>
    struct Features
    {

    }

    //directions of movement for movement vectors quantized into 45-degree angles for 8 directions of movement used for Shadow AI movement direction and animation
    public float dir_angleRad; //-100f would be neutral
    public int dir_angleDeg;
    public int dir_lastFacedAngleDeg;

    //could make the action probability distribution a Dictionary, or something like what would have been seen in the MarkovChain and\or such

    //map of (feature combination) : (action probability distribution) pairs
    Dictionary<string, Dictionary<string, int>> SHMMData; //SHMMData
    Dictionary<string, List<KeyValuePair<string, int>>> SHMMData_maintainOrder; //Part of SHMMData, as one of the randomly selected outcomes, which would be a cycle of generations - with maintaining order of the generation periods within each cycle
    Dictionary<string, Tuple<int, int>> SHMMDataOrdered_cyclePosn; //index and current weight value

    #region About SHMMData_ofmaintainOrderCycles and types with the corresponding implementation of such
    Dictionary<string, List</*Tuple<*/List<KeyValuePair<string, int>>/*, int>*/>> SHMMData_ofmaintainOrderCycles; //where the cycle would likely stick with having a weight value of 1? And whose length would be from when the player would be with the corresponding environment input to: 
    //  when the player would not be in such an environment OR when some time limit for a cycle would have been reached 
    //      (with the time limit being based on some value relative to what would be maybe a typical length of a period, with any experimentation with data to determine such)
    //noting of - due to unlikeliness of obtaining the same cycle in training as another and 
    //computation of determining whether two Lists - for such cycles - would be Equal? 
    //For:  
    //  such an update to weight in adding a cycle, and in randomly selecting a cycle, 
    //  noting of just adding cycles without weight as what could be done instead of a weighted random selection with such weights
    //thus instead, just adding the cycles to a List instead? With noting of such use of statistics for such ... and such of lack of weighted random selection in terms of using weight values ... and instead just selecting among Lists that could be repeated, with such an expected space cost from such for such saving of expected computational time cost as said
    //and noting of such of machine learning and if what I would have would be considered as such, with noting of the transferrability of such a skill and such
    #endregion

        
    List<KeyValuePair<string, int>> SHMMDataOrdered2_currTrainingCycle; //current cycle being constructed within training, among the distribution of cycles - to be inserted upon completion
    int SHMMDataOrdered2_currTrainingCycle_Length;
    int SHMMDataOrdered2_cycleLengthLimit = 240;
    string SHMMDataOrdered2_currTrainingCycle_featureStr; //featureStr that SHMMDataOrdered2_currCycle would be for
    List<KeyValuePair<string, int>> SHMMDataOrdered2_currUsingCycle;
    Tuple<int, int> SHMMDataOrdered2_cyclePosn; //index and current <rmtxth: weight value>position-of-actionperiod of SHMMData_ofmaintainOrderCycles's current cycle given SHMMDataOrdered2_currUsingCycle
    //bool SHMMDataOrdered2_toSwapUsingCycleWhenDone;

    //for fixed cycles for the relative movement implementation
    Dictionary<string, List<List<Pair<genBehaviourData, float>>>> SHMMDataOrdered3_ofFixedLengthCycles = new Dictionary<string, List<List<Pair<genBehaviourData, float>>>>();
    List<Pair<genBehaviourData, float>> SHMMDataOrdered3_currTrainingCycle;
    string SHMMDataOrdered3_currTrainingCycle_featureStr;
    float SHMMDataOrdered3_currTrainingCycle_Length;
    List<Pair<genBehaviourData, float>> SHMMDataOrdered3_currUsingCycle;
    Tuple<int, float> SHMMDataOrdered3_cyclePosn; //index and current position-of-movementdir
    bool resetCurrTrainingCycle_withLoadedDataThisUpdate = false;
    bool resetCurrUsingCycle_withLoadedDataThisUpdate = false;
    bool getCurrMovementAngleAndMag = false;

    public bool SwappedPlacesThisUpdate = false; //for Shadow swapping between player and Shadow

    [Serializable()]
    public struct genBehaviourData : IEquatable<genBehaviourData>
    {
        public float movement_thisUpdate_CWAngleRelativeToSMPos;
        public float movement_thisUpdate_CWAngleRelativeToMNPos;
        public float movement_thisUpdate_Magnitude;
        //could add time period of the movement data, if eg. frame rate would vary and such would lead to varying durations between each movement data added and also used
        public bool isFiring_thisUpdate;

        public bool Equals(genBehaviourData other)
        {
            return movement_thisUpdate_CWAngleRelativeToSMPos == other.movement_thisUpdate_CWAngleRelativeToSMPos && movement_thisUpdate_CWAngleRelativeToMNPos == other.movement_thisUpdate_CWAngleRelativeToMNPos && movement_thisUpdate_Magnitude == other.movement_thisUpdate_Magnitude;
        }
    };

    public bool isTraining;
    public bool isUsing; //whether the Markov AI is to be used
    public bool toggleTrainingAndUsing;

    public enum EnemyDistance { FAR, /*MIDRANGE, */NEAR }

    public enum Action { Attack, Wander, Retreat }
    public Dictionary<EnemyDistance, string> debugStr_dist;
    public Dictionary<Action, string> debugStr_act;

    string prevGenStr = "9"; //a value that would not be intended to correspond to behaviour - as basically "n/a" behaviour
    //string prevGenStr_training = "9";
    //EnemyDistance preveDistance = EnemyDistance.FAR;
    //int prevMaxSpeed = 9;

    //public MarkovChain<MarkovUnit> AIData;
    public List<List<int>> items_weights;
    public List<string> items_weights_alltogether;

    public string markovSaveFilePath;

    //done in order to make saving occur from just one SHMM among the ShadowCharacters
    public static bool savingData;

    public bool loadingData;

    Queue<float> avgClosest2eDistances_nonplayer; //distances for non-player
    static Queue<float> avgClosest2eDistances_player = new Queue<float>(); //distances for player

    //timer for setting prev. movement directions
    float prevMovementDirTimer;
    float prevMovementDirInterval = 0.5f;
    Vector3 prevPosAtStartOfInterval = Vector3.zero;
    Vector3 closestEnemyPosAtStartOfInterval = new Vector3(-9999f, -9999f, -9999f);
    Vector3 medianEnemyPosAtStartOfInterval = Vector3.zero;
    bool resetMovementDirTimerThisUpdate = false;

    const int MAX_PREVDIRS = 1;
    Queue<int> QuantizedDirAngle_RelativeToCM;
    Queue<int> QuantizedDirAngle_RelativeToMN;

    Vector3 prevPlayerPos;
    Vector3 prevClosestEnemyPosRelativeToPlayer;
    Vector3 prevMedianEnemyPosRelativeToPlayer;

    Vector3 prevShadowPos;
    Vector3 prevClosestEnemyPosRelativeToShadow;
    Vector3 prevMedianEnemyPosRelativeToShadow;
    public GameObject minEnemyRelativeToShadow_prevOrNot;
    public bool isFiringThisUpdate;

    public struct gizmoSphereProperties
    {
        public Vector3 position;
        public Color color;
        public float radius;
    }
    List<gizmoSphereProperties> gizmoSpheresToDraw;
    bool enableOnDrawGizmos = false;
    
    //If this is the single Shadow used for training
    //With noting of this and such an instance also being used as a predictive model if used in such a way, as testing
    public bool usedForLoggingTraining;
    public static bool savingMovementData; //save movement data while it would be being tracked by the ShadowCharacter instance that would be also used for logging training

    public int numPlayerAndAIMovementMatchingUpdates, numPlayerAndAIShootingMatchingUpdates, numPlayerAndAIMovingAndShootingMatchingUpdates, numPlayerAndAITotalTestingUpdates;

    //Queue<float> avgClosest2ePosns_nonplayer; //distances for non-player
    //static Queue<float> avgClosest2ePosns_player = new Queue<float>(); //distances for player
    GameObject player;
    public static RuntimeAnimatorController[] shadowAnimations;

    //From https://stackoverflow.com/questions/7787994/is-there-a-version-of-the-class-tuple-whose-items-properties-are-not-readonly-an
    [Serializable()]
    public class Pair<T1, T2>
    {
        public T1 First { get; set; }
        public T2 Second { get; set; }

        public Pair(T1 f, T2 s) {
            First = f;
            Second = s;
        }
    }

    [Serializable()]
    public struct MarkovUnit_moreData : IEquatable<MarkovUnit_moreData>
    {
    //features of this state
        public EnemyDistance eDistance; //very basic feature for initial testing

        //generations of this state
        public Action AIAction;
        //public Vector2 AIAction_MoveVec;

        //tentative features of this state
        //public char neCount; //nearby enemy count
        public char maxSpeed; //speed of enemies
        //public string prev3MoveDirsRelativeToCMandNEPos = "";

        public Vector2 avgClosest2EnemyPosn;

        /// <summary>
        /// For boxing for MarkovChain
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(MarkovUnit_moreData other)
        {
            return eDistance == other.eDistance && AIAction == other.AIAction && maxSpeed == other.maxSpeed && avgClosest2EnemyPosn == other.avgClosest2EnemyPosn;
        }
    }

    [Serializable()]
    public struct MarkovUnit : IEquatable<MarkovUnit>
    {
        //features: enemy distance, behaviour between wander, attack, retreat ...
        //noting of eg. 'using some number of bits' regarding data 
        //bit packing to be space efficient? Could maybe see how the COMP3900 project and\or such was done? With Acho, Brian, Drew, William and me ...
        //Noting of whether such could be done <for such of efficiency> and such in noting how such data would be represented and used, noting how <such would work for the project regarding time efficiency>
        //noting of 200k frames of data, where each frame would have 2 byte-sized enums, with such being 400KB of data - so, space as not an issue anyway for 200k frames
        //though if eg. regarding 30 playthroughs with each having 100k frames, then 6MB?

        //features of this state
        public EnemyDistance eDistance; //very basic feature for initial testing

        //generations of this state
        public Action AIAction;
        //public Vector2 AIAction_MoveVec;

        //tentative features of this state
        //public char neCount; //nearby enemy count
        public char maxSpeed; //speed of enemies
        public Queue<int> QuantizedDirAngle_RelativeToCMAtData;
        public Queue<int> QuantizedDirAngle_RelativeToMNAtData;
        //public string prev3MoveDirsRelativeToCMandNEPos = "";
        //public char weaponChoice; //predominant weapon choice, with proportion of ammo-consuming weapon relative to amount of ammo
        public float movementDir_thisUpdate_CWAngleRelativeToSMPos;
        public float movementDir_thisUpdate_CWAngleRelativeToMNPos;
        public float movementDir_thisUpdate_Magnitude;

        public Vector2 avgClosest2EnemyPosn;
        public Vector2 medianEnemyPosn;

        //classification of this state ...well, noting of weights and such and how such would be relative to another state in noting eg. state transitions and\or such, with <<how the Markov chain><YKWIM>> would work ... such and eg. a la <<n-grams and such><YKWIM>> - adding weight for the <<distribution><YKWIM>> of what would be given the state<< and\or 'sub-states' and\or such with noting of such of the number of such 'sub-states' and such matching the 'order' of the Markov chain><YKWIM>> <leading up to the last state>
        /// <summary>
        /// For boxing for MarkovChain
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(MarkovUnit other)
        {
            return eDistance == other.eDistance && AIAction == other.AIAction && maxSpeed == other.maxSpeed;
        }
    }

    public MarkovUnit prevMarkovData1;

    //variables for collision handling
    public Vector3 prevMovePosition; //public in order to be used e.g. as a variable for enemy's Pursuit behaviour
    public Vector3 prevMoveDelta; //last movement before any collision would have been detected yet
    bool isColliding = false;
    bool collisionOccurredThisUpdate = false; //used to handle just one collision per update
    List<Collision2D> collisionsThisUpdate;
    public int clearTrimAccessCount = 0;

    public static GameObject[] enemies;

    //For the getData method
    const float nearRadius = 3.5f;
    const float nearRadiusSqr = nearRadius * nearRadius;
    const float withinRangeRadius = 9.0f;
    const float withinRangeRadiusSqr = withinRangeRadius * withinRangeRadius;

    //For collision handling
    BoxCollider2D thisBoxCollider2D;
    Rigidbody2D thisRigidbody2D;


    public int i_selected;
    

    // Use this for initialization
    void Start()
    {
        thisBoxCollider2D = GetComponent<BoxCollider2D>();
        thisRigidbody2D = GetComponent<Rigidbody2D>();

        SHMMData = new Dictionary<string, Dictionary<string, int>>();
        SHMMData_maintainOrder = new Dictionary<string, List<KeyValuePair<string, int>>>();
        SHMMData_ofmaintainOrderCycles = new Dictionary<string, List</*Tuple<*/List<KeyValuePair<string, int>>/*, int>*/>>();
        avgClosest2eDistances_nonplayer = new Queue<float>();
        SHMMDataOrdered2_currTrainingCycle_featureStr = "";
        //initialize empty dummy for what can be used as the first 'previous cycle'
        SHMMDataOrdered2_cyclePosn = Tuple.Create<int, int>(0, 0);
        SHMMDataOrdered2_currUsingCycle = new List<KeyValuePair<string, int>>();
        SHMMDataOrdered2_currUsingCycle.Add(new KeyValuePair<string, int>("9", 1)); //default - with 'dummy' generation that would be intended as "n/a" that would be to be replaced
        //SHMMDataOrdered2_toSwapUsingCycleWhenDone = false; //unneeded

        //Testing the Quaternion.Euler code for rotation of vector
        //Vector2 rotatedVector = Quaternion.Euler(0f, 0f, -180f) * new Vector2(-1f, 0);
        //Debug.Log("Quaternion.Euler test of (-1, 0): ("+rotatedVector.x+", "+rotatedVector.y+")");

        float vectorTurnAngle = (Vector2.SignedAngle((Vector2)(new Vector2(0, 1f)) - (Vector2)(prevPosAtStartOfInterval), new Vector2(-1f, 0f)) + 360) % 360;
        Debug.Log("Vector2.SignedAngle test of (-1f, 0) to (0f, 1f): " + vectorTurnAngle);

        //storing each frame in training - though initializations would be as in the prefab
        //isUsing = false;
        //isTraining = true;

        //start with the loaded data
        //loadingData = true;

        player = GameObject.FindGameObjectWithTag("Player");
        shadowAnimations = player.GetComponent<TouchMove>().animations;

        prevPlayerPos = player.transform.position;
        prevShadowPos = transform.position;
        prevMovePosition = transform.position;
        prevPosAtStartOfInterval = transform.position;
        QuantizedDirAngle_RelativeToCM = new Queue<int>();
        QuantizedDirAngle_RelativeToMN = new Queue<int>();

        //for cycles
        SHMMDataOrdered3_ofFixedLengthCycles = new Dictionary<string, List<List<Pair<genBehaviourData, float>>>>();
        SHMMDataOrdered3_cyclePosn = Tuple.Create<int, float>(0, 0f);
        SHMMDataOrdered3_currTrainingCycle_featureStr = "";
        //SHMMDataOrdered3
        SHMMDataOrdered3_currUsingCycle = new List<Pair<genBehaviourData, float>>(); //dummy
        SHMMDataOrdered3_currUsingCycle.Add(new Pair<genBehaviourData, float>(new genBehaviourData(), 0f)); //dummy that would be to be replaced

        resetMovementDirTimerThisUpdate = true;

        //isFiringThisUpdate = false;

        minEnemyRelativeToShadow_prevOrNot = gameObject; //default assignment

        //for debug gizmos
        gizmoSpheresToDraw = new List<gizmoSphereProperties>();
        enableOnDrawGizmos = true;

        //movement collision handling code
        collisionsThisUpdate = new List<Collision2D>();
        //Debug.Log("collisionsThisUpdate: " + collisionsThisUpdate.Count);
        collisionsThisUpdate.Clear();
        collisionsThisUpdate.TrimExcess();

        //debug strings
        debugStr_act = new Dictionary<Action, string>(){
            { Action.Attack, "Attack"},
            { Action.Wander, "Wander"},
            { Action.Retreat, "Retreat"}
                };
        debugStr_dist = new Dictionary<EnemyDistance, string>(){
            { EnemyDistance.FAR, "FAR"},
            { EnemyDistance.NEAR, "NEAR"}
                };
        //debugStr[Action.Retreat] = "Retreat";
        //debugStr
        if(usedForLoggingTraining)
        {
            savingMovementData = false;
            enemies = GameObject.FindGameObjectsWithTag("Enemy");
        }
        Debug.Log("Application.persistentDataPath: " + Application.persistentDataPath);
    }


    void SaveData()
    {
        SerializableSaveDataSHMM data = new SerializableSaveDataSHMM();
        data.AISHMM = SHMMData;
        data.AISHMM_maintainOrder = SHMMData_maintainOrder;
        data.AISHMM_ofmaintainOrderCycles = SHMMData_ofmaintainOrderCycles;
        data.AISHMMOrdered3_ofFixedLengthCycles = SHMMDataOrdered3_ofFixedLengthCycles;
        //edit the data at this point here, and\or otherwise with basically this kind of block of code on saving data?
        //data.AISHMM = SHMMData; //commenting out; not sure if this was needed

        Stream stream = File.Open(SaveLoadSHMM.currentFilePath, FileMode.Create);
        BinaryFormatter bformatter = new BinaryFormatter();
        bformatter.Binder = new VersionDeserializationBinder();
        bformatter.Serialize(stream, data);
        stream.Close();
        savingData = false;
    }

    SerializableSaveDataSHMM LoadData()
    {
        SerializableSaveDataSHMM data = new SerializableSaveDataSHMM();
        Stream stream = File.Open(SaveLoadSHMM.currentFilePath, FileMode.Open);
        BinaryFormatter bformatter = new BinaryFormatter();
        bformatter.Binder = new VersionDeserializationBinder();
        data = (SerializableSaveDataSHMM)bformatter.Deserialize(stream);
        stream.Close();

        loadingData = false;

        // Now use "data" to access your Values
        return data;
    }

    MarkovUnit getData(Vector2 characterPos, bool forPlayer) //returns what would be currData
    {
        MarkovUnit currData;
        //compute median distance of enemies ... or basically determine whether there would be at least 2 enemies within a certain distance

        if(usedForLoggingTraining) //done once by this
        {
            enemies = GameObject.FindGameObjectsWithTag("Enemy");
        }

        //get num. near enemies
        //moved to outside the method
        //const float nearRadius = 3.5f;
        //const float nearRadiusSqr = nearRadius * nearRadius;
        //const float withinRangeRadius = 9.0f;
        //const float withinRangeRadiusSqr = withinRangeRadius * withinRangeRadius;
        int nearEnemyCount = 0;
        float avgEnemyDistanceOfClosest2 = 0;


        float minDist = 99999f;
        float minDist_2nd = 100000f;
        GameObject minEnemy = gameObject;
        GameObject minEnemy_2nd = gameObject;
        float maxNearbyEnemySpeed = 0f;
        #region Comments on determining median enemy pos
        /* median enemy pos: 
         * -enemy with the lowest sum of divergence in rank from each of the middlemost ranks of X position and Y position
         *  -could get median rank with maybe selection sort \ linear searching half the enemies for the minimum and next-minimum, etc. or
         * -could 
         *      sort enemies by the respective position (X or Y) and get the corresponding rank with eg. Mergesort or List<T>.Sort(), then 
         *      sum up each enemies' ranks in terms of divergence from the middle rank (i.e. the middle index of the List)
         *          -maybe having it as a value within each enemy object, or having a Dictionary mapping each enemy to a rank
         *          with noting of this regarding a Dictionary with using Objects and such of references for fast lookup - https://stackoverflow.com/questions/1266469/what-does-net-dictionaryt-t-use-to-hash-a-reference
         *          and so, doing such of a Dictionary to look up specific references, which would only retrieve the objects' references exclusively 
         *      and then get the minimum of such a sum
         *     -with noting of regarding <<not doing><YKWIM>>: eg. assigning ranks during the sort - still such and requiring finding the minimum sum afterwards
         * 
         *  -could note the computational cost in doing this
         */
        #endregion

        Vector3 prevCharacterPosition;
        if(forPlayer)
        {
            prevCharacterPosition = prevPlayerPos;
        }
        else
        {
            prevCharacterPosition = prevShadowPos;
        }

        Queue<float> avgClosest2eDistances; //set to separate queues for player and non-player
        if (forPlayer)
        {
            avgClosest2eDistances = avgClosest2eDistances_player;
        }
        else
        {
            avgClosest2eDistances = avgClosest2eDistances_nonplayer;
        }
        List<GameObject> enemies_withinRange = new List<GameObject>();

        foreach (GameObject enemy in enemies)
        {
            Vector2 enemyPos = enemy.transform.position;
            //Vector2 playerPos = GameObject.FindGameObjectWithTag("Player").transform.position;

            float sqrDistance = (enemyPos - characterPos).sqrMagnitude;
            if (sqrDistance <= nearRadiusSqr) //if enemy is nearby
            {
                nearEnemyCount++;
                //get max speed of nearby enemies
                //quantize speeds into tiers: [0,2), [2,4.5), 4.5 or higher as something that could be done for the 3 tiers of max enemy speeds
                if (enemy.GetComponent<AILerp>().speed > maxNearbyEnemySpeed)
                {
                    maxNearbyEnemySpeed = enemy.GetComponent<AILerp>().speed;
                }
            }
            if(sqrDistance <= withinRangeRadiusSqr)
            {
                enemies_withinRange.Add(enemy);
            }

            float currEnemyDist = (enemyPos - characterPos).magnitude;

            if (currEnemyDist < minDist)
            {
                //update the closest 2 enemies' distances and the corresponding 2 enemies
                minDist_2nd = minDist;
                minEnemy_2nd = minEnemy;

                minDist = currEnemyDist;
                minEnemy = enemy;
            }
            else if (currEnemyDist < minDist_2nd)
            {
                //update the 2nd closest enemy's distance if only <<closer than what was the 2nd closest enemy distance found at this point in code running><YKWIM>>
                minDist_2nd = currEnemyDist;
                minEnemy_2nd = enemy;
            }
        }

        
        //Debug.Log("minDist: " + minDist);
        avgEnemyDistanceOfClosest2 = (minDist_2nd + minDist) / 2; //to be compared with that 180 frames before and\or such

        //currData.neCount = (char)(nearEnemyCount>=9?9:nearEnemyCount); //number of enemies, as a char, with any being 9 or greater <<as 9><YKWIM>> <<so 9 would basically be <<9+\8+ depending on what such would mean><YKWIM>>><YKWIM>>

        //quantize enemy speed into tiers as <<mentioned before><YKWIM>> and have that as part of the SHMM MarkovUnit
        if (maxNearbyEnemySpeed < 2)
        {
            currData.maxSpeed = (char)0;
        }
        else if (maxNearbyEnemySpeed < 4.5f)
        {
            currData.maxSpeed = (char)1;
        }
        else
        {
            currData.maxSpeed = (char)2;
        }

        if (nearEnemyCount >= 2)
        {
            currData.eDistance = EnemyDistance.NEAR;
        }
        else
        {
            currData.eDistance = EnemyDistance.FAR;
        }

        //get prev. directions - 1st, 2nd, and 3rd
        //QuantizedDirAngle_RelativeToCM; //angle quantized to the nearest direction in terms of 45-degree angles CW starting with 1 in the cartesian coordinate plane to 8 (as the 'SE' direction in the cartesian coordinate plane), determined at the end of each interval
        //so, -22.5 to 22.5 would be 1, 8 would be -67.5 to -22.5
        //Queue<int> QuantizedDirAngle_RelativeToMN = new Queue<int>();


        //default values of these
        Vector3 closestEnemyPos = Vector3.zero; //default - not used
        Vector2 medianEnemyPos = Vector2.zero;

        #region get median enemy pos and closest 2 enemy pos

        //make it so at least the closest 2 enemies - if they exist - would be added to enemies_withinRange, if no other enemies would exist in such as a part of such of enemies_withinRange
        if(minEnemy != gameObject && !(enemies.Length < 1))
        {
            enemies_withinRange.Add(minEnemy);
        }
        if(minEnemy_2nd != gameObject && !(enemies.Length < 2))
        {
            enemies_withinRange.Add(minEnemy_2nd);
        }

        #region get median enemy pos
        //getting median enemy pos - noting computational cost in doing such
        Dictionary<GameObject, int> EnemyAndDivergenceFromMiddlePosRank = new Dictionary<GameObject, int>();
        List<GameObject> enemiesOrderedByXPos = new List<GameObject>(enemies_withinRange);
        List<GameObject> enemiesOrderedByYPos = new List<GameObject>(enemies_withinRange);

        //sort lists in ascending order?
        int middleRank = enemiesOrderedByXPos.Count / 2;
        enemiesOrderedByXPos.Sort(new Comparison<GameObject>((x, y) => (int)(Mathf.Floor(x.transform.position.x - y.transform.position.x))));
        enemiesOrderedByYPos.Sort(new Comparison<GameObject>((x, y) => (int)(Mathf.Floor(x.transform.position.y - y.transform.position.y))));
        
        GameObject medianPosEnemy = null;
        if (enemiesOrderedByXPos.Count > 0)
        {
            //add X and Y pos divergence from mid
            for (int i = 0; i < enemiesOrderedByXPos.Count; i++)
            {
                EnemyAndDivergenceFromMiddlePosRank[enemiesOrderedByXPos[i]] = 0;
            }
            for (int i = 0; i < enemiesOrderedByXPos.Count; i++)
            {
                EnemyAndDivergenceFromMiddlePosRank[enemiesOrderedByXPos[i]] += Mathf.Abs(middleRank - i);
                EnemyAndDivergenceFromMiddlePosRank[enemiesOrderedByYPos[i]] += Mathf.Abs(middleRank - i);
            }
            medianPosEnemy = enemiesOrderedByXPos[0];//enemy with minimum divergence from middle rank

            //get enemy with minimum divergence in medianPosEnemy
            foreach (var item in EnemyAndDivergenceFromMiddlePosRank)
            {
                if (item.Value < EnemyAndDivergenceFromMiddlePosRank[medianPosEnemy])
                {
                    medianPosEnemy = item.Key;
                }
            }
            medianEnemyPos = medianPosEnemy.transform.position;
        }
        #endregion
        #region get mean enemy pos

        #endregion

        /*if (enemiesOrderedByXPos.Count >= 2)
        {
            closestEnemyPos = (minEnemy.transform.position + minEnemy_2nd.transform.position) / 2;
        }
        else */if (enemiesOrderedByXPos.Count >= 1)
        {
            closestEnemyPos = minEnemy.transform.position;
        }

        #endregion

        if (prevMovementDirTimer >= prevMovementDirInterval || closestEnemyPosAtStartOfInterval == new Vector3(-9999f, -9999f, -9999f)/* - as initialization*/)
        {
            if (closestEnemyPosAtStartOfInterval == new Vector3(-9999f, -9999f, -9999f)) //initialize if not done already
            {
                closestEnemyPosAtStartOfInterval = closestEnemyPos;
                medianEnemyPosAtStartOfInterval = medianEnemyPos;
            }
        }
        //Debug.Log("prevMovementDirTimer: " + prevMovementDirTimer);
        if (prevMovementDirTimer >= prevMovementDirInterval)
        {
            resetMovementDirTimerThisUpdate = true;
            //end of getting the median and avg enemy pos at the end? of interval?
            prevMovementDirTimer -= prevMovementDirInterval; //basically reset of the timer

            //determine angles to be added to QuantizedDirAngle as the prev. angles, replacing any after the 3rd
            Vector3 movementDir = (Vector3)characterPos - prevPosAtStartOfInterval;

            //get angle of (position from (the player position at start of interval)) relative to (the enemy positions from (the player position at the start of the interval))
            //positive CW angle
            float movementDirAngle_RelativeToCM = (Vector2.SignedAngle(movementDir, (Vector2)medianEnemyPosAtStartOfInterval - (Vector2)(prevPosAtStartOfInterval)) + 360)%360;
            float movementDirAngle_RelativeToMN = (Vector2.SignedAngle(movementDir, (Vector2)closestEnemyPosAtStartOfInterval - (Vector2)(prevPosAtStartOfInterval)) + 360)%360;
            //quantize the angles
            int dir = 1;
            int degArcLength = 45;
            int currArcStart = -degArcLength / 2;


            //add the corresponding dir to the respective queues
            #region enqueue and dequeue the QuantizedDirAngle queues
            //handle dir that would deal with 'negative' (being at the latter part of the positive) and positive first as a separate case, i.e. when dir is 1
            if (movementDirAngle_RelativeToCM >= currArcStart+360 || movementDirAngle_RelativeToCM < currArcStart + degArcLength)
            {
                QuantizedDirAngle_RelativeToCM.Enqueue(dir);
            }
            if (movementDirAngle_RelativeToMN >= currArcStart+360 || movementDirAngle_RelativeToMN < currArcStart + degArcLength)
            {
                QuantizedDirAngle_RelativeToMN.Enqueue(dir);
            }
            currArcStart += degArcLength;

            //if the angle would be within any of the arcs found, add corresponding dir - for the positive-only angles
            for (dir = 2; dir <= 8; dir++)
            {
                if(movementDirAngle_RelativeToCM >= currArcStart && movementDirAngle_RelativeToCM < currArcStart + degArcLength)
                {
                    QuantizedDirAngle_RelativeToCM.Enqueue(dir);
                }
                if (movementDirAngle_RelativeToMN >= currArcStart && movementDirAngle_RelativeToMN < currArcStart + degArcLength)
                {
                    QuantizedDirAngle_RelativeToMN.Enqueue(dir);
                }
                currArcStart += degArcLength;
            }

            if (QuantizedDirAngle_RelativeToCM.Count > MAX_PREVDIRS)
            {
                QuantizedDirAngle_RelativeToCM.Dequeue();
            }
            if (QuantizedDirAngle_RelativeToMN.Count > MAX_PREVDIRS)
            {
                QuantizedDirAngle_RelativeToMN.Dequeue();
            }
            #endregion
            
            //update the prev. pos, and prev. enemy pos'es that would be used for the curr. movement dir. generation
            prevPosAtStartOfInterval = (Vector3)characterPos;
            closestEnemyPosAtStartOfInterval = closestEnemyPos;
            medianEnemyPosAtStartOfInterval = medianEnemyPos;
        }
#if UNITY_EDITOR
        //Draw debug sphere at positions for SM and MN
        //Gizmos.color = Color.red;
        //Gizmos.DrawSphere(medianEnemyPos, 0.6f);
        //Gizmos.color = Color.blue;
        //Gizmos.DrawSphere(closest2EnemyAvgPos, 0.6f);
        gizmoSpheresToDraw.Clear();
        gizmoSpheresToDraw.Add(new gizmoSphereProperties() { color = Color.red, position = medianEnemyPos, radius = 0.7f });
        gizmoSpheresToDraw.Add(new gizmoSphereProperties() { color = Color.blue, position = closestEnemyPos, radius = 0.5f });
#endif

        prevMovementDirTimer += Time.fixedDeltaTime;

        currData.QuantizedDirAngle_RelativeToCMAtData = new Queue<int>(QuantizedDirAngle_RelativeToCM);
        currData.QuantizedDirAngle_RelativeToMNAtData = new Queue<int>(QuantizedDirAngle_RelativeToMN);
        //get direction relative to prev. position in cycle
        //closest2EnemyAvgPos
        //medianEnemyPos


        //quantize distance and classify it into NEAR, FAR
        //currData.eDistance = EnemyDistance.FAR; //removed this< via commenting<< such><YKWIM>> out here> ...in favour of existing code that classifies such <<above><YKWIM>><< with a nearEnemyCount><YKWIM>> value



        #region noting of determining action - with noting of this and not used within Using as the action would be generated (in the Using() method) rather than retrieved


        //**
        // get relative direction relative to the two enemy posns, so two directions that would be vectors whose directions 
        // would be relative to directions of enemy positions each with half the weight
        // though noting of such of the enemy posns and being with current enemy posns compared to the prev character posns ...
        //**
        Vector2 movementDir_thisUpdate;
        //float movementDir_thisUpdate_CWAngleRelativeToSMPos;
        //float movementDir_thisUpdate_CWAngleRelativeToMNPos;
        //float movementDir_thisUpdate_Magnitude;

        //Vector2 vec = Quaternion.Euler(0f, 0f, 45f) * new Vector2(0f, 1f);
        //if (forPlayer)
        //{
            movementDir_thisUpdate = characterPos - (Vector2)prevPlayerPos;
            currData.movementDir_thisUpdate_CWAngleRelativeToSMPos = (Vector2.SignedAngle((Vector2)medianEnemyPos - (Vector2)(prevPosAtStartOfInterval), movementDir_thisUpdate) + 360) % 360;
            currData.movementDir_thisUpdate_CWAngleRelativeToMNPos = (Vector2.SignedAngle((Vector2)closestEnemyPos - (Vector2)(prevPosAtStartOfInterval), movementDir_thisUpdate) + 360) % 360;

            if(isTraining && getCurrMovementAngleAndMag)
            {
                Debug.Log("medianEnemyPos: (" + medianEnemyPos.x + ", " + medianEnemyPos.y + "); closest2EnemyAvgPos: (" + closestEnemyPos.x + ", " + closestEnemyPos.y + "); mag: "+ movementDir_thisUpdate.magnitude);
                Debug.Log("CWAngleRelativeToSMPos: (" + currData.movementDir_thisUpdate_CWAngleRelativeToSMPos + "; CWAngleRelativeToMNPos: " + currData.movementDir_thisUpdate_CWAngleRelativeToMNPos + ";");
                getCurrMovementAngleAndMag = false;
            }
            if(currData.movementDir_thisUpdate_CWAngleRelativeToMNPos == 0)
            {
                Debug.Log("CWAngleRelativeToMNPos is 0 right now");
            }


            currData.movementDir_thisUpdate_Magnitude = movementDir_thisUpdate.magnitude;
        //}
        //else
        //{
        //    //not used
        //}

        //get attack and classify it ...

        //classification of whether the AI would be doing an "attacking" behaviour - which would just be shooting and maybe approaching, "Wander" behaviour - which would be having been moving sideways towards enemies <<if not alternatingly towards and away from enemies, noting of how such would be done in terms of such, noting of eg. <<rather large><YKWIM>> <<amounts of><YKWIM>> movement that would yield a <<low><YKWIM>> difference in distance from enemies><YKWIM>>, or "Retreat" behaviour - which would be moving away from enemies
        //where such of moving away from enemies would be in increasing the distance between the closest enemy, or increasing the average distance from the closest 2 enemies
        //with comparison with 2 seconds before, or 120 frames before, with noting of eg. positions tracked of eg. enemies in the past 120 frames and\or distances of such enemies from the player in the past 180 frames ... with eg. a queue storing such distances of each frame ... or keeping track of the past 180 frames ...
        //Queue<float> avgClosest2eDistances = new Queue<float>(); //across 180F

        //though could note of how the difference could be due to just the enemies moving and not necessarily the player moving; could note this as a <<super simplification><YKWIM>>
        currData.AIAction = Action.Attack; //set in order to avoid Visual Studio <<from ><YKWIM>>displaying an "error" due to lack of initialization
        float distanceDiff = 0;
        float prevDistance = 0; //made for debugging; otherwise could do without this var
        if (avgClosest2eDistances.Count >= 150)
        {
            //can compare the 150f prior with the curr.
            prevDistance = avgClosest2eDistances.Dequeue();
            distanceDiff = avgEnemyDistanceOfClosest2 - prevDistance;
        }
        else
        {
            if (avgClosest2eDistances.Count > 0)
            {
                prevDistance = avgClosest2eDistances.Peek();
            }
            distanceDiff = avgEnemyDistanceOfClosest2 - /*((avgClosest2eDistances.Count > 0)?avgClosest2eDistances.Peek() : 0f)*/prevDistance; //get the earliestmost unit of data
        }
        //Debug.Log("curr dist: " + avgEnemyDistanceOfClosest2 + ", prev dist: " + prevDistance+"; distanceDiff: "+distanceDiff);
        if (distanceDiff > 1)
        {
            //consider such an amount of positive difference as retreat
            currData.AIAction = Action.Retreat;
        }
        else if (distanceDiff > -1)
        {
            //consider such a small \ nonexistent difference as wander
            currData.AIAction = Action.Wander;
        }
        else
        {
            //consider such an amount of negative difference as attack
            currData.AIAction = Action.Attack;
        }
        avgClosest2eDistances.Enqueue(avgEnemyDistanceOfClosest2);

        #endregion

        #region Determining of behaviour vector for Shadow AI plan
        //determining of player behaviour as: 
        //  -a vector along the direction of the median position of enemies and 
        //  -a vector along the direction of the median position of the 'most-nearby enemies' (i.e. closest (# of enemies summing to a minimum strength value) and\or what could be something regarding the closest enemy \ something like that)
        //any of center of mass and\or median position of nearby enemies and such as a point to look at - as current environment input
        //with data of said players' parameters of movement direction and features (sequence of prev. movement directions, distance and speed of center of mass of enemies, distance and speed of the 'most-nearby enemies')
        //with any of inference and\or such of such said vectors
        /*
         with formula: 
         sum of: 
            median-enemies vector ('weighted by' (i.e. weight, being equiv. to) prevalence of being what would be within the arc that the vector along the direction of the median position of enemies would be in the middle of)
            +
            most-nearby-enemies vector ('weighted by' prevalence of being what would be within the arc that the vector along the direction of the median position of 'most-nearby enemies' would be in the middle of)
        etc. (for those within arcs of vectors not in such directions, and\or vectors in the opposite directions and such)
        for each combination of 'within-the-respective-arc' <<condition cases><YKWIM>>
        and could note any of 
        */
        #region -weighted random selection of eg. movement in such directions that could be considered as retreating and\or such, such as within some arc,
        /*-with noting of eg. directions that would have data corresponding to such in such arcs with such and any relative increasing of weight around such directions within such arcs by some amount as some sort of 'gradient' at each of such points - so, maybe with some linear increase of weight around such directions within such arcs
            -<<though noting regarding making such into a 'gradient' and if other <<modellings of such weights towards directions><YKWIM>> would be more <fitting\worthwhile>><YKWIM>>: <<with noting of ><YKWIM>>what sort of means of relative increasing weight around such directions <<and\or such regarding such weight><YKWIM>> would be most accurate in imitating human behaviour of such movement in such directions
                -with <<eg. ><YKWIM>>following any sorts of <<patterns><YKWIM>> regarding such directions in the data and consistency of the weights with such <<patterns><YKWIM>>
                    -<<with likely patterns of: 
                        -'humps'? <<Maybe just as part of the 'clusters' as said below><YKWIM>>
                        -'clusters' with gaussian distributions around a specific direction - determined by random variables leading to divergence from a specific direction
                        and noting of if eg. someone would <<frequent><YKWIM>> multiple <<specific directions><YKWIM>>, then multiple of these clusters <<weighted by probabilities\weights around such said specific directions><YKWIM>>
                            -with data being <<with each <<datum><YKWIM>> set up as eg. classified as part of a specific direction and within the <<gaussian distribution of said specific direction><YKWIM>>><YKWIM>>
                        -variation in varying approaches, with maybe various other directions from the 'specific direction' and being roughly equally likely and\or such due to being different, with noting of maybe - if the type of person would be someone who would continuously vary their direction - such eg. being more likely than previously <<visited directions><YKWIM>>
                            <<-noting of eg. if one would try to move as far as possible from their previously visited direction and\or such><YKWIM>>

                    and noting of also basically with just about random directions with determination based on map location and such basically varying randomly
                        -with noting of eg. 'clusters' or 'variation in such approaches' would still exist as a bit of a factor in movement behaviour
                    with noting of how likely that each of <<such patterns><YKWIM>> would be><YKWIM>>*/
        /*
                with whatever of such would be <<evidence><YKWIM>> of going towards certain directions, if data would exist for different directions across the retreat arc (i.e. arc of what directions would have data within what would be <<classified\<within constraints>><YKWIM>> of being retreat behaviour, or not using the terms 'retreat,' 'wander,' and 'attack'
                and noting of how behaviour would follow a function to determine behaviour, with 
                    -such data determining the probability distribution of behaviour based on how said data would be incorporated in determining such behaviour
                        -with interpolation of input environment to 
                            (probability distribution of periods? of output movement vector \ 
                            probability distribution of output movement vector \ 
                            <<Noting of this: ><YKWIM>>probability distribution of output movement vector for the period in between previous and curr. movement vectors
                                -<<with whatever eg. would lie on the distribution, noting of eg. selecting along an arc though with weights being with <<<<eg. what could be ><YKWIM>>data that would be evid. of some output movement vectors leading to higher weights for eg. behaviour being with movement with such said output movement vectors><YKWIM>>><YKWIM>>
                            \
                            output movement vector for the period in between previous and curr. movement vectors \ 
                            output vector for the FixedUpdate in between previous and curr. movement vectors) 
                        based on data of such)*/
        #endregion
        /*    or*/
        #region  just random selection ...
        /*-with noting of such of <<directly following the vectors as seen in data><YKWIM>> ...noting of saving vectors as opposed to the eg. bit-based data I would have been considering up to this point
        and such as opposed to the conditions of 'within-the-respective-arc' and not 'within-the-respective-arc' with such and being vectors instead
        and such vectors and being relative to such said directions with respect to the center of mass and 'most-nearby' <<enemies><YKWIM>> - with noting of such 
        <<and not eg. learning according to eg. finding more samples of data and\or such as machine learning would be intended to do and\or such with ANNs and\or such><YKWIM>> <<in noting of such of the training space and\or such><YKWIM>><< and noting of such and discarding the concept of 'training space' <with such and lack of use of such in considering of the AI> with such and being with such a different ><YKWIM>>use of the data <<with lack of eg. reinforcement and\or such of data><YKWIM>><< though eg. quantizing of samples could be still ><YKWIM>>possible <<though noting of if such would be ><YKWIM>>worthwhile<< with such an amount of data and ><YKWIM>>any absence of <<eg. meeting a minimum regarding training space><YKWIM>>
        <<and any of such of Shadow mode and incorporating such into eg. the middle of the game as opposed to being during the 2nd playthrough as something I could do
            -with noting of such as I could note in an e-mail to Aaron Hunter><YKWIM>>
        <<with noting of such and what atsi would have said regarding such of generative models and being able to <<not have that many samples><YKWIM>><< with noting of
         such and missing such of samples for features and\or such><YKWIM>>><YKWIM>>
            -<<and could check with atsi regarding such with such space><YKWIM>>
            <<noting of such of the Shadow AI and use of such as a predictive model><YKWIM>> <<and if such could be done><YKWIM>> <<regarding player behaviour><YKWIM>> <<in testing\validation><YKWIM>> <<without such quantization
                -with noting of quantization just for such of prediction, though lack of quantization in generation, though noting of how much that such would serve as data that would test\validate the Shadow AI><YKWIM>>
                though noting of actually quantization occurring for the final directions done, and could note such in testing
                <<with such and how I could mention such to Aaron Hunter, though noting of such and if it would be <<required\better to have such approved<\<checked with>> by Aaron Hunter><YKWIM>>

        -noting of <in thinking about such <<- of output directions -><YKWIM>>> <<such of such directions relative to the 'center-of-mass' of enemies and the 'most-nearby' enemies and such use with respect to generation for <<- as relative to - ><YKWIM>>a different 'center-of-mass' of enemies and 'most-nearby' enemies><YKWIM>>
            <<noting if eg. such vectors could sum up to each other to make up the vector of movement in the direction relative to such <<two positions relative to the player><YKWIM>> and\or such><YKWIM>> <<where the weight of each movement vector relative to such <<two positions relative to the player><YKWIM>> could be <<customized><YKWIM>> - with such and eg. putting more weight on movement with respect to the center of mass or the 'most-nearby enemies' as <<customizable><YKWIM>>><YKWIM>>
            <<though noting if a weighted summation of <<such vectors><YKWIM>> would ><YKWIM>>accurately reflect human behaviour <<with going in between both of the <<vector directions><YKWIM>>><YKWIM>>
                -with noting of such of 'how much that <<approaching\avoiding \ <<moving with respect to><YKWIM>>><YKWIM>> the' said <<relative positions><YKWIM>> that the player would do in movement

            and 
            <<not doing <<at least currently><YKWIM>> as of this writing@10/11/18, 1:28PM><YKWIM>> -could note of <<eg. if players would also weigh movement with respect to the 'most-nearby' enemies and the 'center-of-mass' of enemies and\or such differently, and if such weights could be learned from inference
                with noting of movement towards directions and such leading to eg. averaging towards directions with some weights, as what would be learned, or maybe going towards certain directions with different weights
                with noting of eg. if more consistent relative vector directions could be found with different weight adjustments that could be determined, and any of such in calculation of 'most likely player weights if relative vector directions would be more likely to be consistent'
                and noting of such expenditure in computation of such><YKWIM>>

            <<though as <<simplification with <<what could work><YKWIM>>><YKWIM>>, can hard-code set, fixed weights <<for each of said two vectors><YKWIM>> for now, as of this writing at 10/11/18, 1:26PM><YKWIM>> 
            */
        #endregion

        #region So, <<regarding such of random selection><YKWIM>><< with saving the 2 <<relative><YKWIM>> vectors><YKWIM>> <<as data><YKWIM>> <<for generation><YKWIM>>, and <<features being as aforementioned><YKWIM>>
        /*-noting of prev. movement direction and quantizing to the 8 directions in such use of the data, as features quantized into a string
                -<<with interpolation\extrapolation of such said data of directions would be an alternative to quantizing><YKWIM>>
                -<<with prev. movement direction being 
                    <the quantized sum of the vectors 
                    or not, with noting of <<determinability of such prev. movement direction's relative vector to two positions as adjusted to such of a prev. movement direction's relative vector to two positions in the data><YKWIM>>>
                    
                    <<with being as <two movement directions - one relative to the 'SM' and one relative to the 'M-N'>><YKWIM>>
                    relative to the <<'center-of'mass' and 'most-nearby' enemies' positions 
                with such said positions being at the timepoint of( the start of the interval across which the position difference of the player would be determined for) said previous directions,
                    -as opposed to re-adjustment of positions and corresponding <<relative ><YKWIM>>vector directions to with the current environment input
                where 
                    data of <<relative ><YKWIM>>vector directions would be <<drawn from><YKWIM>> <<such with positions from environment input at the timepoint of when the data would have been obtained in training><YKWIM>>
                    with <<noting of noting 
                        <<the relative two 'SM' and 'M-N' enemies'><YKWIM>> positions in the data, 
                        or 
                        <<two movement directions - one relative to the 'SM' and one relative to the 'M-N'><YKWIM>> in the data 
                            -<<with noting of such as unweighted in such data as 'previous movement directions' features without interpolation><YKWIM>>
                        with noting of how much that this could <<allow data with some certain <'SM' and 'M-N' enemies' positions> to be used for <<prev. movement directions with different ><YKWIM>><'SM' and 'M-N' enemies' positions, as long as such relative movement directions would be the same>><YKWIM>>
                    in such a re-adjustment of the previous movement vector to be 
                    <<generated according to the data with such features of previous movement directions with such said directions as relative to the enemies' positions><YKWIM>>
            and so, noting of - with reiteration\clarification of the aforementioned prev. movement directions
                the prev. movement directions <<using 2 quantized directions of movement in terms of the position difference from 0-0.5sec. prior to the 0.5sec. before that for the last previous, and then 0.5sec. prior for the 2nd previous, and comparisons with the 0.5sec.-before position for the respective previouses><YKWIM>> as <<features that could be used with data><YKWIM>>
                whereas 
                <<the current direction would be one of the generations, as 2 vectors, where 
                    each vector would be relative to <<a relative enemy position><YKWIM>> and <<comprise some fraction<< - which would be the weight<< of the vector><YKWIM>> -><YKWIM>> (such as half) of the vector's magnitude, 
                    both vectors summing up to said current direction><YKWIM>>><YKWIM>>
                        -noting of: 
                        cycles lasting the period of an interval that would comprise a prev. movement dir, and 
                        with the generation dir being relative only to the enemy positions at the start of the interval, as the prev. movement dir would be relative to the original player pos., or 
                        said generation dir being <<at each update in the cycle><YKWIM>> and <<relative to the enemy's current positions, in said cycle><YKWIM>>
                        <<though prev. movement dir being different - basically being 'quantized' in terms of the movement direction to one direction across the 'cycle' as opposed to the generation dir, which would be with such movements <<for each update in the cycle><YKWIM>>><YKWIM>>
                        (*Past<<\Curr.,WhenLaterIfSo,><YKWIM>>WorkingPlace)
                
                -<<with noting of such and training space
                with noting of such and such as what could be clarified regarding training space and could <<mention\check><YKWIM>> such with Aaron Hunter regarding such training space and what would be regarding such for features but not generations><YKWIM>>
                    ><YKWIM>>
                ><YKWIM>>
            where directions would be with the ...
            ><YKWIM>>
            <<with such relative to the enemy <<relative positions><YKWIM>>><YKWIM>>

            */
        #endregion
        /*
        <<as opposed to retreat or attack as vectors><YKWIM>>


to determine movement direction for the respective generation, such as retreat or attack
 */
        #endregion


        //regarding: 
        //  -'cluster' patterns: noting of implementation of gaussian distributions as done that would be based on classified samples
        //      -with samples classified as ...
        //  -variations: noting ...
        //noting of use of such SHMM data for a given feature set - with weights and all - and converting it to the aforementioned probability distribution with such inferences of gaussian distributions for clusters and such

        //and converting to gaussian distributions with noting of classifications with maybe if statements for ranges <<with numbers based on fractions><YKWIM>>
        //  -with eg. mean and variance of a gaussian distribution and getting those from the 'classified sample data'
        //  with noting eg. distances between sample data for classification, and eg. identifying clusters that would be likely enough to be following a gaussian distribution in which sample data would be classified if clusters are found
        //  and otherwise, characterizing the data not as eg. gaussian-distributed clusters
        //      -noting of how such would be identified, with noting of eg. how close that it would follow such a pattern in math\statistics ... and eg. probability of following a gaussian distribution of some range of means and variances
        //          -noting of how such could be done, with noting of expenditure in the math involved in determining such a probability
        //      and noting of any simpler approaches regarding such of finding eg. what could be close to a gaussian-distributed cluster
        //  and noting of pros of having gaussian distributions to characterize samples over eg. just random selection based on the data, with noting of 
        //  maybe just direct data distribution <<with such of being set into such vectors as calculated if such would be calculated><YKWIM>> without extrapolation and seeing how well that such an AI would characterize behaviour
        //  with such and being a la a 'probability mass function' though with just the data, with weights and whatever would be with how <<unlikely><YKWIM>> that such weights would <<<<exceed><YKWIM>> 1><YKWIM>>

        #region Determining of map location for Shadow AI plan
        /*Determining of map location in AI: 
            -behaviour\generation would include data of current map location
                -<<<1/7/19><YKWIM>>: noting of if eg. the current map location would determine the current destination vs. eg. cycling ... <<in noting of such of the following written points and\or such regarding map location, with noting of Egain\reward of such said approaches and\or such with taking the current map location into account in the current destination for every current destination, vs. cycling and\or such><YKWIM>>>
                <<<1/10/19, edited on 1/15/19<, if not <wrtxlater: both 1/14/19 and 1/15/19>> and\or such to the extent that any edits would be done, with any removal of writing to be removed and\or such if such would count><YKWIM>>: noting of what of these intended innovations and\or such of hardcoding would be worth the space in scope for the game, with noting of what would be covered in the report of the practicum, and noting of such of what could be <wrtxlater: <<>selection of the most valuable and\or such with such of innovation, with general use of such and personal application of it for myself in terms of machine learning use in what would be applied and\or tested in this practicum><YKWIM>><<<1/15/19><YKWIM>>: >>
            -AI would cycle around said map locations and move towards any of said map locations, with such as the destination, and then on the next map location, updating the said AI's destination to some other of said data of the current map location

            with such as weighted in movement, in addition to such of movement relative to enemies
                -with such said weighting and with what could be a higher weight as enemies would be further away and/or less in number nearby
                -with noting of such and if such would follow eg. typical paths of a player with regards to the map location, and if such would look 'completely random' and unlike a player in terms of map location behaviour
                with noting of such of such Shadow AI and 'frequenting map locations as the player would' with such of similar frequencies about such said locations
                
                noting of what could be selections of nearby locations as such data points selected regarding locations ... in: 
                not varying too much in terms of paths from the player's paths in such of movement, and noting of such of eg. locations that could be positioned as 'later' than the previous positions, with each position having an assigned value, and 
                noting of eg. if positions with numbers in between the current position and eg. a nearby position, and with considering said nearby position as with the path as not enclosed within the nearby area<< as I would note><YKWIM>>, 
                and noting of such and what could be discarding and/or weighting less of such said nearby positions as well as nearby positions that would be previous in terms of the positional order in such data points nearby
                
                with noting of such and such as opposed to eg. following data points in order for paths, in such with having some variation and/or randomness in such said Shadow AI behaviour while still looking like the player's behaviour
                
                and as any alternate methods of such map location handling of behaviour: 
                not by such an order ...
                with following paths or not ... and/or weighting following paths or not ...
                and noting of such said weightings ...
                with any methods of weightings
                    -where following the path was one weight
                with noting of how much a player might diverge in their movement behaviours - with <<noting of such in doing weighted random selection or not><YKWIM>>
                    -and what would be 'typical divergence' from eg. paths and\or such, and\or 'typical varying' of behaviour that a player might do
                    in noting of what such a Shadow AI might do
                    with noting of how much that such of following the path and/or not following a path would be seen as like a player's behaviour as opposed to an "AI"'s behaviour, with such resemblance and\or such*/
        #region eg. movement styles and\or such that could be resembled and\or imitated 
        /*-with noting of eg. movement styles and\or such of players in play that could be resembled and\or imitated with such of an AI
        -with <what would be including><rmtexthere:  eg.>: 
            -'seeing new things' / 'exploring' / 'avoiding repetitive path behaviour'
                -noting of eg. destinations, and such of varying of such said destinations, and distances between destinations and distances between eg. paths and such
                and noting of eg. if the paths would be sequentially taken
                    -with such and an idea of it being easier to remember<wrtxtlater:  / <keep track of>> what paths would have been previously taken and/or such
                -noting of if such paths and/or locations would have already visited, any of switching to other movement styles as what could be done, unless such of 'exploring' would continue
                with any of tracking and classifying behaviour as eg. switching to another behaviour style
            -'enemy mobbing strategies'
                -with any consistent paths
                though noting of eg. variation between said consistent paths, with noting of variation that would be within what would be viable and\or still also effective in being one of said 'enemy mobbing strategies'
                and any variation based on the current stage, and such of eg. enemy spawn patterns and avoiding enemies and/or such with whatever could be of map locations that would be avoiding enemies and/or such of chokepoints and/or such
                -noting of if such a mobbing strategy would be an 'individual' mobbing strategy and/or would have synergy with eg. other Shadows that would be set up
                    -noting of effectiveness of Shadow AI with eg. not imitating the weapon used by eg. a player with such a mobbing strategy
                    and noting of eg. if a player would cease movement at a chokepoint and use the laser in attacking enemies that would be trying to get through the chokepoint
                    -with noting of eg. any viable movement areas for what would be eg. a place of other Shadow AIs and/or the player to attack the mob
            -'being at a chokepoint'
                -with whatever movement could be done within what would be viable and/or still also effective
                -with if there would be multiple different chokepoints that could be used depending on eg. the wave, and/or if eg. the player would pull back to some other route and/or chokepoint if one chokepoint would be 'exhausted' already
                    -noting effectiveness of Shadow AI if such said chokepoints would have been with eg. different weapons being effect<with text as written then removed here: ing>ive at such said chokepoints
            -'being in open-field areas'
                -with a player and having interest in having eg. more options in terms of movement
        and noting of the difficulty of any of said movement playstyles and such in viability of <rmtxtthatwouldbehere: imitating/>setting up such by the usual player of the game, with any of eg. focus on survival of the players
            -and noting of how eg. difficulty of the game could be set such that said movement playstyles would be doable and/or such


        and such in noting eg. behaviours and moreso with any sequential patterns and less of randomness in such said behaviours
    and noting of imitation of said divergence and/or such
    */
        #endregion
        /*
        */
        #region how such would be imitated/handled by the AI
        /*and in how such would be imitated/handled by the AI: 
                            -with: 
                                -following paths of map locations and such as behaviour imitated, alongside such regarding behaviour with respect to enemies?
                                And with: 
                                    -for 'seeing new things' / 'exploring' / 'avoiding repetitive path behaviour': 
                                        -such similar of a kind of following with such, and following the style of path following: 
                                            -sequential vs. non-sequential, with classifying such into such
                                    -for 'enemy mobbing strategies': 
                                        -tracking such paths, adding any random value of position along the path as well that would be still viable and/or selecting among a viable area in movement direction along the path
                                        with noting of such and such as weighted towards such points along the path, with such of eg. progress in terms of from beginning to end of the path, and 
                                        said random value of position being in terms of to directions that would not make a difference to progress from beginning to end of the path <<as said><YKWIM>> from the current position of the path, and said random value being <with the fluctuations being with the same 'patterns' of deviation of random movement of the player>
                                    -for 'being at a chokepoint': 
                                        -any of <<moving along a path with said ><YKWIM>>random variation as said for 'enemy mobbing strategies' and then any of random movement from beginning to end of the path 
                                        and when at the chokepoint, such of random movement <<and\or such><YKWIM>> <that would be a la humanlike random movement that would resemble the amt. random movement in map location within the chokepoint of the player>
                                   -for 'being in open-field areas'
                                        -with noting of any classification of such said behaviour and what rate of position being away from eg. obstacles and chokepoints would be found
                                            -with noting of any overlap with this and any of the other playstyles and such, and what could be classified independently of the aforementioned playstyles
                                        and applying such a classification regarding said map locations
                                -any identification of such playstyles - of movement - by said AI? In such learning behaviour ... with classifying of eg. behaviour into such playstyles, before handling such separate playstyles - of movement - with separate implementations with
                                    -any of eg. such of inference based on the data obtained, according to the playstyle - of movement - identified
                                with what would be done based on the most likely playstyle - though noting of when such would not fall into such playstyles and/or such
                                and noting of how such would be characterized, though noting of if such would improve chances at resembling human behaviour than otherwise, and noting of such of expected improvement in such imitation in human behaviour with such
                                with noting of what could be done of movements if they would not fall into any of the <<listed playstyles><YKWIM>> 
                                    <in terms of being likely enough<< and\or such><YKWIM>> that such would fall into any of such said playstyles for such an imitation to be 'likely enough' to resemble the human behaviour with such expected improvement in imitation of human behaviour> 
                                and what could be used of a 'more random' playstyle with the aforementioned of weighted movements along paths when other imitations would not be worthwhile compared to said 'more random' playstyle in imitation
                                */
        #region Making human behaviour being of such said playstyles
        /*
        with noting of how likely that human behaviour would be of such said playstyles, with what kinds of things that the player might be focusing on, with such of the difficulty of doing such said imitations
            -with noting of how the game could make the game less difficult such that such said playstyles could be more imitated
            while making the game still challenging <with eg. making <<player actions be what would matter to the player and\or such in the game, as opposed to 'anything working' and player's behaviour being believed to be not very consequential and\or challenging and\or such, with eg. avoiding enemies and\or such
            with noting of maybe checkpoints and such after every 5 waves, or after every 4 waves, with such of resetting the playthrough to such checkpoints
                -and could note any of such a mention to Aaron Hunter regarding such said checkpoints
                with a prompt of if the player would want to continue from such a said checkpoint at such a point
                with noting of what would be learned of the Shadow AI, with such taking into account all of such gameplay and/or such
                    -with noting of eg. a death counter in the game, and any achievement for beat<rmtxhere: hi>ing the game without any deaths
           with noting of if said checkpoints would still make imitation of said Shadow AI something that would not be 'too difficult'<< and\or such regarding being difficult and\or such><YKWIM>>
            ><YKWIM>>>
                -with: 
                -<where text here of "less health"<< and\or such><-nmn>> was removed>more health
                -<<more immediate shadows><YKWIM>> as mention<rmtxhere: g>ed below
                    -with noting of what could be of such teaching of Shadows and such and such use with<wrtxlater: in><wrtxlater:  ><rmtxh<rmtxhere: : >ere: ie>the Normal mode, and again in the Shadow mode
                    where such could be done with having multiple different Shadow AI types in the Shadow mode after one playthrough of the Normal mode, with such of setting up such said Shadows in the Shadow mode
                    <<with noting of how much value that there would be in emergent gameplay with such teaching of the Shadow AI><YKWIM>>
                    <<and noting of if such said Shadow AI could effectively <<imitate <<creative><YKWIM>>><YKWIM>> player ideas, with such of replayability and such of such teaching of Shadow AIs><YKWIM>>
                    <<or, could note of eg. other players' Shadows and such as what could be used in such a Shadow mode as opposed to the player teaching multiple different playstyles in order for the Shadow mode to have a 'set of player types'
                    and could have eg. any preset Shadow mode AIs that could be used, as well, for the Shadows
                    with noting of eg. a description of each Shadow AI type and/or such for the player to imitate and/or such><YKWIM>>
            -though noting of eg. rewarding the player with a 'true ending' if they would complete the Shadow mode as opposed to the normal mode, and such in encouraging such said playstyles
            though noting of how much the player would actually want to do such if it weren't for such a reward, with such of said gameplay
            -with noting of eg. maybe more immediate feedback regarding behaviour and such with what would be including reminding the player of the Shadow AI behaviour and such and how such could be imitated, throughout the Normal mode, and what could be making the player interested in teaching the Shadow AI and figuring out eg. how such teaching would work throughout said Normal mode, with eg. making several different Shadow AIs throughout the Normal mode
                -with noting of what I could tell Aaron Hunter regarding such of said teaching and such in revision of the proposal
                with such of such teaching and such for the game for application of such said AI
                -and noting of what could be said regarding such of machine learning in the report and such found of the effectiveness of machine learning in gameplay, with how much of a role that such would have in improving gameplay, although noting of eg. synergy - with eg. of hardcoding and/or such - involved in making such machine learning improve gameplay and such
                -and\or noting of eg. such said imitating of behaviour as not done for the Shadow mode, but just the Normal mode and/or such with such said Shadows and being a sidekick and/or such as said elsewhere, with noting of such with such as a revision of the project I could mention to Aaron Hunter
                    -with such regarding gameplay and/or such, with 'greater tangibility/transparency' regarding the Shadow AI
                    and/or the Shadow mode being the only mode, and the Shadow AI gradually learning and/or such of imitation of the player behaviour, and such as being apparent to the player, with noting of such differences between the Shadow mode and normal mode and such and lessening the differences between the Normal mode and Shadow mode in terms of such AI behaviour
                        -<<<Noting of whatever of this would have been thought while LoC, while outside this curr. Visual Studio code, originally, with noting of such and being maybe 1 of ~1-3 or so<wrtxlater: <, if not ~2-4>> thoughts that would have been thought originally while outside <<Visual Studio in typing in this "ShadowSHMM.cs" file><YKWIM>> as well: ><-nmn>>though noting of eg. behaviour of eg. taking cover with Shadows protecting the player, and such dependence of behaviour on Shadows'>
                            and noting of such said learning by Shadows as well, and noting such as a feature to take into account in behaviour
                            <<alongside such of enemy positions, with noting of if such of Shadow positions would be done as well - though the Shadow may not want to imitate how the player would be making use of Shadows in imitation for the uses of the player in management of AI behaviours and/or such?><YKWIM>>
                    with noting of such said Shadow AIs and starting as inactive or not as well
                    and such of where the player could reset the Shadow AI behaviour whenever the player would want, as well
                    with any of such and immediate player learning and/or such
                    with maybe introduction of said Shadows on the 4th wave or so, with such an introduction with any tutorial text and/or such
                    with the player and warping to the initial starting position again on such a said wave, with such an introduction of the Shadows, or maybe the Shadows and spawning relative to the player, always, with any of eg. spawning right beside the player if the Shadow's usual spawn point would not be on walkable terrain and/or such
                    and noting of eg. saving/managing Shadow AI behaviour and/or such in the Normal mode as well
                    with maybe gradually obtaining more Shadows across the waves, on eg. the 4th <wtlater: wave>, then the 8th <wtlater: wave>, then the 12th <wtlater: wave>
                    and/or eg. controlling what periods of behaviour that the Shadow AI would imitate
                        -<<though noting of such of teaching Shadows and such a different environment with such gradual introduction of Shadows><YKWIM>>
                        <<with noting of if Shadows would be a feature to take into account in behaviour><YKWIM>>
                 <<with noting of how clunky that eg. trying to teach the AIs would be, and what could make such less clunky><YKWIM>>
                    -<<with noting of such regarding clunkiness and such as a challenge of the project in the report for the project><YKWIM>><< with such of machine learning and making such involved in the game with such of not being 'clunky'><YKWIM>>
                    and noting of <<what could be done in ><YKWIM>><<reducing clunkiness - which would maybe be ><YKWIM>>undesirable for gameplay<< if so><YKWIM>> - with such use of machine learning and <<teaching the Shadow AI><YKWIM>> with such said machine learning: 
                        -<<maybe such of the emergent gameplay and such of such Shadows and such of <<scrapping\cutting><YKWIM>> such ideas of encouraging teaching the Shadows for strategic teaching, and leaving such as without such emergent gameplay as <<pushed forth><YKWIM>> in noting said clunkiness, with noting of such of eg. having such said Shadows as an avatar as all that would be desirable instead
                            -with noting of such as opposed to eg. demands of understanding of how the learning of Shadow AI behaviour would work, and training for optimization for such of the Shadow mode and such and if such would be a goal for the Shadow mode, then such being: 
                                -limiting in eg. behaviours in the Normal mode
                                -clunky and/or difficult and/or <unfair and/or confusing> <regarding such teaching>
                            and instead, such of eg. optimization for such of the Shadow mode as what could be something that may not be necessary, but could be done by the player as some sort of achievement and/or such                                                             -with noting of eg. score attacking and such that could be done and noting of
                                        -a stretch goal of a high scores list that could be mentioned in the report with the Shadow mode and Normal modes <<and eg. Shadow survival achievements, with eg. a high scores list of Shadow-exclusive damage and number of waves survived and/or such><YKWIM>>
                                    with noting of such as what could be mentioned to Aaron Hunter
                        ><YKWIM>>
                        <wrtxtlater: <<>and/or maybe such of said Shadows and any goal of having such said Shadows surviving as well in the Shadow mode, with such teaching as improving individual survival as well, and any of having as a goal of ensuring that each Shadow would not die, with any game over and/or otherwise punishment for Shadows dying
                        and noting of value in 'having such an AI play as oneself' with any intrinsic value and/or such of such><YKWIM>>
                        <<and noting of having the Shadows as enemies as well ...><YKWIM>>
                        <<and/or having the Shadows as rivals, eg. in score attacking><YKWIM>>
                        */
        #region <<any applications regarding><YKWIM>> <<such of Shadow behaviour that would be not necessarily optimized with such of playstyles...><YKWIM>>
        /*
        with noting of <<any applications regarding><YKWIM>> <<such of Shadow behaviour that would be not necessarily optimized with such of playstyles, with lack of eg. intended synergy in training such Shadows><YKWIM>>: 
            -such of <<the aforementioned - of Shadows as enemies and/or rivals><YKWIM>>
                -<<noting of eg. survival time of such other Shadows and/or such and trying to survive longer than said rivals><YKWIM>>
            -<<noting of the aforementioned of eg. such of online sending of behaviours and/or such><YKWIM>>
            -<<what <<other ><YKWIM>>kinds of applications of personalized things such as such would exist: 
                <<if one could eg. play as the enemies and/or such><YKWIM>> <<with any of having control over the enemies and trying to defeat one's Shadow AI><YKWIM>> ...
                -whatever could be of rewarding one's personalized creation with whatever value could be given to it <<for what it would be><YKWIM>> <<with whatever unique experience and/or such that such could provide><YKWIM>> <<with noting of eg. such such as a custom level and/or such><YKWIM>>
                    -<<with noting of eg. each kill by the Shadow AIs being undesirable on some wave and/or such, with such said Shadow AIs' kills leading to such said enemies respawning as stronger versions of said enemies and/or as multiple enemies, and actually better behaviour by said Shadow AIs being worse for the player><YKWIM>>
                    <<though noting of eg. not making it so the player would try to make the Shadow AIs die as soon as possible by eg. not attacking enemies either
                    with noting of eg. 
                        -if such enemies killed by the Shadow AI would become <<basically intangible to the Shadow AI but not to the player, and enemies killed by the player would become basically intangible to the player but not to the AI and/or such><YKWIM>>
                <<with whatever could be made interesting of one's own behaviour as used ... that could make gameplay more dynamic and/or varied and/or different><YKWIM>>
                    -<<with how consequential that such behaviours could be made to be><YKWIM>>
                        -<<and maybe what could be done in order to add replay value to the game with the player and being interested in playing differently with seeing what kinds of effects that such would make on the gameplay><YKWIM>> */
        #region <<with noting of if the player could just continue playing the way that they were playing, and how such could be eg. prevented and\or with such a gameplay situation otherwise improved from<wrtxltr: <wrtxltr: \>for> such a means of playing><YKWIM>>
        /*
                        <<with noting of if the player could just continue playing the way that they were playing, with such of the Shadow AIs and just imitating the player so it would be as if the world would just be divided into 4 in a way, with each <<player \ Shadow character><YKWIM>> <<basically doing the same t<hing and eg. making the game more dull in that way, ><YKWIM>>and <<noting of said Shadows and if they would eg. all stick together into a single location, and if such would just be increasing the firepower at said location><YKWIM>>
                        <<and noting of if such said Shadow AIs would not improve, but rather worsen gameplay with such><YKWIM>>
                            -<<and noting of eg. if Shadows could instead be used as a special abilit<rmtxhere: i>y, with limitations, and be seen as such a power and\or ability rather than just having further extensions to oneself all the time, though 

                            noting of such and how much that such could add to gameplay over eg. the Shadows copying the player's every move directly><YKWIM>>: 
                                -<<having 'more intelligence' and\or such with eg. survival and\or such against enemies than just 'direct copying' of the player's every move, such that all of the Shadows would not have to be eg. taken into account in movements and\or such><YKWIM>>
                                <<though noting of whether such would be worth the machine learning and\or such><YKWIM>> <<with such an improvement over such an implementation, although such would not be limited to such in the application of said machine learning><YKWIM>>
                                <<with such and if such would be 'the best' application of machine learning without said stretch goals><YKWIM>>
                                -<<noting of the uploading of AIs and such ><YKWIM>><<with such value, though, nonetheless><YKWIM>>
                            <<though noting of viability of just ignoring the other Shadows and treating such separately on eg. said Shadows spreading and\or such><YKWIM>>
                            <<noting of eg. treating Shadows like mercenaries <<in eg. Diablo II><YKWIM>>, with such and having to buy them at the Shop, and such of how effective that it would be for Shadows to not be protected, and noting of how much that diversification in gameplay could be present based on the AI that would be involved in being protected and\or such><YKWIM>>
                                <<-giving said Shadows lifebars on top of them as well><YKWIM>> <<and said Shadows healing as you would in between waves><YKWIM>>
                            <<though noting of if players would eg. find such said Shadows to not be worth getting if their AIs would make such difficult to protect, with noting of if such would make said Shadows 'worse'><YKWIM>><< based on said Shadows' playstyles><YKWIM>>
                                -<<noting of eg. making said Shadows cheaper if they would have fewer kills and\or <wrtxlater: less damage and\or >such><YKWIM>> <<and so, <wrtxlater: effectiveness><rmtxhere: strength<\effectiveness>> of said Shadows not necessarily being better><YKWIM>>
                                <<with noting of how long that such a gimmick would last><YKWIM>> <<with such and noting of optimization goals and eg. adjustment of difficulty in a way, with such said Shadows, as well><YKWIM>>
                            
                            -noting of any way of making eg. Shadows make more of a difference to gameplay
                                -with <<eg. any synergy and\or interaction with said Shadows that could be done><YKWIM>> <as something <<more 'forced' and\or such><YKWIM>>>
                                    -with noting of <<sharing health with Shadows as an idea><YKWIM>>
                                        -though noting of how much of a disadvantage that there would be of if <<Shadows would be spread apart compared to if said Shadows were together><YKWIM>>
                                    -<<noting of whatever could be done regarding the Shadows and being spread apart and what could be done with making such with making a difference to gameplay that would be interesting and\or such><YKWIM>>
                                        -<<with noting of eg. balancing that could be done with Shadows that would be spread apart vs. together><YKWIM>>
                                            -<<noting of eg. more vision and\or such with said Shadows><YKWIM>>
                                            <<and could note of eg. allowing the player to teleport to Shadows><YKWIM>>
                                            <<with such and any advantages of being 'exploratory' and\or such as a player><YKWIM>>
                                            <<and could note of eg. 'summoning' Shadows that could be done ... though noting of such and if such would be an issue if said Shadows were not spread out><YKWIM>>
                                            <<with noting of how clunky that summoning Shadows would be if said Shadows would keep spreading apart><YKWIM>>
                                             -<<noting also of AOE and such of Shadows and said AOE being more effective if Shadows were together><YKWIM>>
                                            <<though noting of any ><YKWIM>>drawbacks of said Shadows being together and\or such of <<lack of avoiding enemies><YKWIM>> <<in staying very close in a map location><YKWIM>>, though noting of <<said map location and if the Shadows would be 'rather close' though still avoiding enemies><YKWIM>>
                                    <<with noting of eg. if taking map location into account would be ><YKWIM>>worthwhile <<in Shadow AI behaviour, in noting of such balancing of Shadows that would be spread apart vs. together><YKWIM>>
                                        <<-and any of bringing Shadows together as maybe an ability and\or upgrade of said Shadows that could be purchased and\or such, with lack of eg. map location as learned><YKWIM>>
                                        <<and\or such of controlling whether Shadows would be together or not><YKWIM>> 
                                    -noting of what could be <<a la a co-op action game and such and if such said Shadows could act like co-op players of an action game and\or such as a result with such said learning
                                        -with such as a la if 'one could play with oneself' and what such would be like, as how the game would be considered as><YKWIM>>
                                        <<and noting of how ><YKWIM>>humanlike <<that such Shadows could behave<wrtxtl:  as>><YKWIM>>
                                        with what could be any kinds of experiences <<that would improve gameplay, with eg. any additional gameplay and\or varied gameplay as a result><YKWIM>> seen in eg. co-op games: 
                                            <<Noting of such and what may\would apply: ><YKWIM>>
                                                -<<playstyles that could be considered><YKWIM>>
                                                -<<'what it would be like' in terms of eg. the challenges and\or undertakings and\or processes and\or such in playing with such a player
                                                    <<-with such of gameplay in noting of what of eg. in eg. fighting a player in fighting games <and\or otherwise eg. competitive 1v1 games> would apply to such of playing with such a player in co-op
                                                        -with eg. strategies in playing against\with such a player with such that could emerge with 'playing the player'><YKWIM>>
                                                        and noting of eg. dependence of what a player would do on what one would do, with eg. countering what such an opponent player would do in a 1v1 competitive game and whatever processes would be involved in such and such gameplay resulting from such
                                                        with eg. dependence and such of synergy with players in co-op<, with any <<such said ><YKWIM>>dependence on how one would play>
                                                        and noting of what could be done with eg. game mechanics that would make eg. more depend<wrtxlater: e>nt actions and\or such
                                                        with <<such said dependent actions and being what players would ><YKWIM>>be eg. likely to <<do, as opposed to eg. not playing differently from without Shadow characters and\or being not much different and\or such><YKWIM>>
                                                            <<-noting of eg. if one would be playing as if the player 'would be split with his power having been released into Shadows' with such individual portion being weaker, and such said Shadows being 'harder to control' and so with eg. one having the goal of keeping all of the power intact and\or such with managing of the Shadows <with such power being 'lost from the player's immediate conscious control' <<as how the lore would consider such><YKWIM>> <<and such of playing along said Shadows as a challenge><YKWIM>>>, in 
                                                            making such of behaviour as being dependent and\or such><YKWIM>><< with noting of such of adding value of said Shadow AI, with such uniqueness and\or such of said gameplay in doing such even if there might\may be people who may not like said gameplay - with noting of basically considering such said gameplay to be subjective but noting of such said Shadow AI behaviour and being useful><YKWIM>><< and noting of such in having value as an innovative component of said project, with such of playtesters and\or such><YKWIM>>
                                                            */
                                                            #region <<noting of the market potential, with such regarding innovation><YKWIM>
                                                            /*<<with noting of the market potential of said innovation, though
                                                                -though noting of such and if such could be somewhat not of all value as present for the project to be satisfactory, with noting of eg. if such would be of interest by the audience, with noting of eg. marketing such to those who may be interested in top-down shooters and\or top-down action games and maybe RTSes and\or such
                                                                with 'bullshitting' the market potential, with noting of eg. such and interest by the playtesters, and noting of such of the project and such constraints of an innovative component and noting of if such would be enough ...
                                                                and noting of - on looking at an e-mail exchange I had with Erika Ram <regarding innovation, with an e-mail on 2017-06-13 by Erika Ram> - such of offering a new product, good or service as what can be considered as innovative, and so noting of such of having said innovative component improve the game's market potential and noting of if such would necessarily be something required of the innovative component, with such of uniqueness and\or such
                                                                with such of such said exploration and what could exist of any findings and\or such from the exploration and experimentation of said project that could be eg. used in the future, with such value from the ideas, and with eg. if interest were to become towards such a kind of game design that would be unique and\or such, such use of said project's machine learning component with such a market potential resulting from such a situation and\or such of the market if such a said situation would exist><YKWIM>>
                                                                */
                                                            #endregion
                                                                /*
                                                            <<noting of such and basically referring to such as a different game mode, as opposed to the Normal mode - with such as being more of a 'leader' regarding the Shadows <where said Shadows would be <<like subordinates\'subordinates'><YKWIM>>>, with such and being such of a 'custom game mode' in a way
                                                                -and noting of such of what could be done as 'the leader' of said Shadows, with eg. such of summoning Shadows<<, and eg. maybe controlling how close that the Shadows would be to be to the player and limiting distance from the player with such said learned behaviour as well><YKWIM>> and\or such, 
                                                                    though noting of such and what would be considered as a stretch goal and\or such
                                                                    and noting of such in noting such of market potential
                                                                    with noting of such and such stretch goals and such that would be evidence of market potential
                                                                    and such that would be satisfactory, with such a project, with noting of uniqueness and such and if such would be enough for <wrtxlater: value<<\such><YKWIM>>> in the project with innovation><YKWIM>>
                                                                -<<noting of maybe an idea of - as 'the leader' - having a recolored sprite with such distinguishing oneself from the Shadows, or maybe ...said Shadows and any of distinguishing of said Shadows from the 'leader'><YKWIM>>
                                                                    -<<and noting of eg. a stretch goal of a minimap><YKWIM>>
                                                                        -<<and eg. any alerts and\or such when Shadows would be under attack and\or such><YKWIM>>
                                                                        -<<and maybe eg. arrows that would indicate the positions of the Shadows at any point, with noting of the difficulty of such a stretch goal><YKWIM>>
                                                                    <<with noting of such and such in aiding handling of the Shadows><YKWIM>>
                                                                    <<and noting of said minimap and aiding the player and\or such in avoiding enemies and\or such as well><YKWIM>>

                                                                    <<and noting of what would be difficulty and\or clunkiness and\or fairness in such of managing Shadows without such 'leader' features and\or such><YKWIM>>
                                                                    <<though noting of eg. zooming out the camera and such that could be done as well><YKWIM>>
                                                                        <<-with such zooming and such control of such and being eg. in the options menu, and noting of eg. providing access to the Options menu at the place of the Enter Shop button, with what could be where the shop would be displayed if the shop would be available there, and with eg. any of switching between an Options and an Enter Shop screen in such a place><YKWIM>>
                                                                    <<and noting of such and if such could be exclusi<rmtxhere: ng >ve to the Shadow mode, and such as eg. an unlock of the game><YKWIM>>
                                                                        <<-with noting of such greater field of view and\or such and what would be indication of such of being for multiple Shadows, as opposed to just oneself, <and being more with eg. management of all of said Shadows as what the game would be moreso about> <<with such of recommendations made of keeping all of the Shadows alive so that one could keep the firepower of all of them, or maybe having the player figure such out, and\or explaining and\or saying something basically being of 'how your power depends on the life of such Shadows' and\or something like that><YKWIM>> with noting of eg. moving the camera and such to other Shadows and\or towards other Shadows while being the player><YKWIM>> <<with noting of eg. if the camera would be a la one in Smash bros. where it would zoom out such that it would be able to display the player and the Shadows><YKWIM>>
                                                                        -<<though noting of the camera implementation and amt. that would be involved in making said camera function smoothly, such as eg. following the player vs. the player and multiple Shadows and\or such><YKWIM>>
                                                                    -<<and eg. noting of lifebars for each Shadow><YKWIM>>
                                                                    -<<and noting of eg. swapping between Shadows in terms of control, with noting of such manual control and such in eg. saving said Shadows and any coordination that could be done that way, as well, and taking advantage of eg. spread Shadows that way as well and such with having greater incentive to keep such said Shadows alive with such control with such interest in gameplay even apart from such of survival><YKWIM>>
                                                                        <<with noting of such as come up with while talking to atsi and mentioning such of trying to come up with ways to make the AI more useful<wrtxlater: << and\or improve gameplay><YKWIM>>> and\or such><-nmn>>
                                                                        -<<noting of if access to Shadows would be implemented with such Shadows being accessible regardless of whether they would be on screen or not, with such of eg. maybe what would be seen in Smash and\or such of the arrows pointing offscreen
                                                                        with noting of such and such use of greater vision with Shadows offscreen with such spreading of said Shadows across different areas with whatever would have been said of such already of vision, and such of teaching Shadows of being spread apart and such incentive of doing such><YKWIM>>
                                                                            -<<noting of such I could say to Aaron Hunter regarding such, with such additions regarding the Shadow AI and what would be additional to the proposal, with such I could say regarding the tester feedback and such of adding gameplay value to said AIs, with noting of such of 
                                                                            innovation value and\or emergent gameplay and 'realizing said emergent gameplay' as part of the innovation with noting of such regarding finding a useful way to apply the AI into the project
                                                                            with such as what could be considered as part of additions made from playtester feedback - with such regarding the AI and such of such being based on playtester responses as ways to improve the experience for <such an audience> \ <such playtesters>><YKWIM>>
                                                                        <<with being able to swap places<wrtxlater: , as well as health<wrtxlater:  and <wrtxltr: current >facing directions>,> with Shadows<rmtxhere: , as well as health>><YKWIM>>
                                                                            -with noting of <<showing offscreen Shadows with arrows towards such said Shadows pointed at the direction that would be from the player character towards the Shadow on the edge of the screen at the point that a line from the player to the Shadow would intersect at the edge of the screen><YKWIM>>
                                                                    
                                                                    <<and with such, noting of the diffi<< - noting of text having been cut off here at some point, noting of such as of 12/5/18, 11:09PM><-nmn>><< - ><-nmn>>

                                                             <<And can note of if such would be with any deviation from the proposed project and if so, noting of such and what could be asked of Aaron Hunter><YKWIM>>
                                                        ><YKWIM>>
                                                 
                                            <<Noting of what might not apply: ><YKWIM>>
                                                -<<team synergy><YKWIM>>
                                            */
        #endregion
        /*

        <<... PUT IDEA HERE regarding such that would fall in line with such said of what could be done with such said learning with such said Shadow AIs ...><YKWIM>>
        -'having something for everyone' with regards to eg. goals of playstyles, a la such done with open-world games<< to the extent that such would be done in said open-world games and\or such><YKWIM>>
        -and\or basically the Shadow mode and different playstyles <leading to different challenges and\or difficulties for the player< compared to <<if the playstyles were no different between eg. players><YKWIM>>>
        -<<eg.: 
        -protecting the Shadows 
            -with eg. mobbing enemies as protection of said Shadows
        vs.
        -capitalizing on eg. Shadow mobs and\or such and\or 'targetting Shadows'
        though noting of eg. if Shadows would be altogether or not altogether, and such in if such scenarios could be done with the current means of learning
        <<<With any of such and thinking while outside room - with noting of being in washroom prior for the duration that there would have been any of being in washroom prior as well: ><-nmn>>-with noting of map location and focus on a certain map location, vs. eg. dispersing everywhere, and such convergence that could be taught if doing such>><YKWIM>>>
        -noting of handling mobs of enemies with all of the Shadows altogether, but fewer enemies at a time with the Shadows spread apart, and larger numbers of said enemies at a time when the Shadow AIs would be more defensive, and smaller numbers when said Shadow AIs would be more aggressive
        with noting of eg. use of the spread attack with enemies that would fall under patterns that spread shots would be effective against
        and noting of eg. less effective AOE skills when said enemies would be spread apart moreso
        and noting of any of such of such behaviours leading to encouraging different playstyles and/or such as a result of the Shadow AI behaviour
        with noting of if the Shadows would be together, then such being where the player would have been maybe <<and\or such><YKWIM>> successful <wrtxlater: <<in not moving much><YKWIM>>> in a single place <<and\or such><YKWIM>>
        -<<stretch goals that could be recorded in the report><YKWIM>>: 
        -noting of eg. <<an idea of 'hard-coded' enemy Shadows and\or ally Shadows and any challenge of making one's ally Shadow better than the said enemy Shadows, as a stretch goal for if I were to continue the project after the practicum that could be written in the report><YKWIM>>
        -<<having eg. some sort of 'war' between 4 strong enemies and you and 3 Shadows as a 'final boss battle' and\or such as a level><YKWIM>>
        -<<though noting of said Shadows and being for fighting against such of such enemies ...><YKWIM>>
        <<noting of eg. a 'MOBA-style' wave and\or such with such in such a battle><YKWIM>>
        -<<any mini-games that could make use of such said Shadow AIs><YKWIM>>
        -<<any other <<and\or such><YKWIM>> noting of regarding the game design><YKWIM>> <<with noting <rmtxhere: including o>><YKWIM>><including of >game design differences
        -noting of how eg. playstyles <<- with noting of such of eg. other entities<wrtxltr: \characters> and\or such><YKWIM>> can lead to varied gameplay in other games
        -such as Smash, etc.
            -faster-paced gameplay with eg. aggressive players
        -<<MOBAs? \ MMOs? \ <Diablo games?>< \ <other action RPGs>?>><YKWIM>>
            -<<synergy><YKWIM>> <<between such <wrtxlater: characters> could be different><YKWIM>>
                -<<tanking vs. supporting behind><YKWIM>>
                <<though tanking and being undesirable in this game <<I would be making><YKWIM>> as what would be probable for most players and\or such><YKWIM>>
                <<though if one could take control of said Shadows once dead, noting of such
                    -with such as an idea for the report, in noting of such and being more strategic and\or such with getting the Shadows to all be alive, with how much that their lives would matter compared to yours and\or such><YKWIM>>
                <<any of eg. Delta Prison on enemies for protecting aggressive Shadows, Psi Leap in managing nearby Shadow AIs, Psi Burst in making use of AOE for large numbers of enemies close together with eg. close-together and\or defensive\fleeing Shadows><YKWIM>>><YKWIM>>
                <<with noting of if skills could be revised to add more synergy and\or such with Shadows of different <<AI playstyles><YKWIM>>><YKWIM>>
        and noting of how such could apply to this game
        -maybe rather than time-based waves, enemy count-based waves, and defeating all of the enemies in order to progress on each wave and limiting number of enemies on the stage at a time
            -leading to eg. faster-paced gameplay with aggressive players
            and shorter waves in terms of time

        ><YKWIM>>
        */
        #endregion
        /*
      */
        #endregion
        /*
        with noting of how transparent that such imitation would look and with how 'non-humanlike' that such an imitation would look like, and/or with how 'hard-coded' that such imitations would look like as opposed to being 'more dynamic' / 'more generalized' / 'more imitative/learning' in having such a classification
        and/or if such behaviours would be covering basically all of the 'behaviour ways' that one could have in the game, such with if such would look like such would be showing the game's limits in behaviour and 'not doing anything that would not be already mapped out by the developer' and/or 'not doing anything that would be new'
            -with noting of such of replay value, and
            'relative linearity' of the game
            and/or
            with noting of if basically the game would be with 'the actions and being hardcoded' <'to cover the different' <<ways to play><YKWIM>>> with expenditure being with <<lack of elegance><YKWIM>> <<with handling ><YKWIM>>each situation <<and such with such of handling responses to each outcome, with noting of such and such a la eg. Mitsuku and/or such that would be such a chatbot and if such would be ><YKWIM>><the most efficient way to do what would have been intended and/or such for achieving such an outcome, with noting of if such would be worthwhile in coding of such and/or such for such an outcome of such imitation of the player>
            */
        #endregion
        /*
                and noting of how much of such would be useful in learning about machine learning and/or innovating about machine learning that would be applicable in <<such a field of ><YKWIM>>machine learning <<and\or otherwise of computer science><YKWIM>>
                    -noting of such said machine learning and what would be of hardcoding to make said machine learning more effective, with such of an application to games
                        -with noting of what could be noted of such said hardcoding in the report and/or such and how such would have been something that would have been in aiding gameplay, as opposed to eg. machine learning approaches, with the developer finding such hardcoding approaches as what solution could be come up with 
                        in making such said machine learning effective in gameplay and/or such and/or otherwise imitate the player so as to make the player's teaching of the AI function as a player might intend the AI to function
                        or, if such would not yield <wrtxtherelater: worthwhile >gameplay improvements, could also cut such an idea of handling map locations entirely and/or <wrtxtherelater: just >the aforementioned approach regarding handling map locations
                apart from such weighted random selection, noting of 
                eg. 
                    sequential selection, and 
                    with
                    any weighted random sequential selection or non-weighted/<evenly weighted> random sequential selection            
        and\or
            -if eg. a player's path in the map would be tracked, and with the Shadow AI and whatever could be following such of said paths
                -or, could exclude said paths from such learned, with noting of what kind of limitation that such would be
        */
        #endregion

        //and noting of a for loop for such if statements

        //Noting of precondition and postcondition: the prev. player values are used exclusively in Using(), and the prev. Shadow values are used exclusively within code in Training() - and both being prior to the execution of this code
        if (forPlayer)
        {
            prevPlayerPos = player.transform.position;
            prevClosestEnemyPosRelativeToPlayer = closestEnemyPos;
            prevMedianEnemyPosRelativeToPlayer = medianEnemyPos;
        }
        else
        {
            prevShadowPos = transform.position;
            prevClosestEnemyPosRelativeToShadow = closestEnemyPos;
            prevMedianEnemyPosRelativeToShadow = medianEnemyPos;
            minEnemyRelativeToShadow_prevOrNot = minEnemy;
        }
        
        currData.avgClosest2EnemyPosn = closestEnemyPos;
        currData.medianEnemyPosn = medianEnemyPos;

        return currData;
    }

    MarkovUnit_moreData getData_more(Vector2 characterPos, bool forPlayer) //returns what would be currData
    {
        MarkovUnit_moreData currData;
        //compute median distance of enemies ... or basically determine whether there would be at least 2 enemies within a certain distance

        GameObject[] enemies = GameObject.FindGameObjectsWithTag("Enemy");

        //get num. near enemies

        //moved to outside the method
        float nearRadius = 3.5f;
        float nearRadiusSqr = nearRadius * nearRadius;
        int nearEnemyCount = 0;
        float avgEnemyDistanceOfClosest2 = 0;
        Vector2 avgEnemyPosOfClosest2 = Vector2.zero;

        float minDist = 99999f;
        float minDist_2nd = 100000f;
        GameObject minEnemy = gameObject; //default value <<as I <rmtxth: could see and >would consider such to be><YKWIM>>
        Vector2 closestPos = new Vector2(9999f, 9999f);
        Vector2 closestPos_2nd = new Vector2(10000f, 10000f);
        float maxNearbyEnemySpeed = 0f;

        Queue<float> avgClosest2eDistances; //used for comparison of distances with past distances <<at least><YKWIM>> //set to separate queues for player and non-player
        if (forPlayer)
        {
            avgClosest2eDistances = avgClosest2eDistances_player;
        }
        else
        {
            avgClosest2eDistances = avgClosest2eDistances_nonplayer;
        }

        //Queue<float> avgClosest2ePosns;
        //if (forPlayer)
        //{
        //    avgClosest2ePosns = avgClosest2ePosns_player;
        //}
        //else
        //{
        //    avgClosest2ePosns = avgClosest2ePosns_nonplayer;
        //}

        foreach (GameObject enemy in enemies)
        {
            Vector2 enemyPos = enemy.transform.position;
            //Vector2 playerPos = GameObject.FindGameObjectWithTag("Player").transform.position;

            //float sqrDistance = (enemyPos - characterPos).sqrMagnitude;
            ////if (sqrDistance <= nearRadiusSqr) //if enemy is nearby
            //{
            //    nearEnemyCount++;

            //    //get max speed of nearby enemies
            //    //quantize speeds into tiers: [0,2), [2,4.5), 4.5 or higher as something that could be done for the 3 tiers of max enemy speeds
            //    if (enemy.GetComponent<AILerp>().speed > maxNearbyEnemySpeed)
            //    {
            //        maxNearbyEnemySpeed = enemy.GetComponent<AILerp>().speed;
            //    }
            //}

            float currEnemyDist = (enemyPos - characterPos).magnitude;

            if (currEnemyDist < minDist)
            {
                //update the closest 2 enemies' distances
                minDist_2nd = minDist;
                minDist = currEnemyDist;

                //update the closest 2 enemies' positions
                closestPos_2nd = closestPos;
                closestPos = enemyPos;

                minEnemy = enemy;
            }
            else if (currEnemyDist < minDist_2nd)
            {
                //update the 2nd closest enemy's distance if only <<closer than what was the 2nd closest enemy distance found at this point in code running><YKWIM>>
                minDist_2nd = currEnemyDist;

                closestPos_2nd = enemyPos;
            }
        }

        //Debug.Log("minDist: " + minDist);
        avgEnemyDistanceOfClosest2 = (minDist_2nd + minDist) / 2; //to be compared with that 180 frames before and\or such
        avgEnemyPosOfClosest2 = (closestPos + closestPos_2nd) / 2;

        //currData.neCount = (char)(nearEnemyCount>=9?9:nearEnemyCount); //number of enemies, as a char, with any being 9 or greater <<as 9><YKWIM>> <<so 9 would basically be <<9+\8+ depending on what such would mean><YKWIM>>><YKWIM>>

        //quantize enemy speed into tiers as <<mentioned before><YKWIM>> and have that as part of the SHMM MarkovUnit
        if (maxNearbyEnemySpeed < 2)
        {
            currData.maxSpeed = (char)0;
        }
        else if (maxNearbyEnemySpeed < 4.5f)
        {
            currData.maxSpeed = (char)1;
        }
        else
        {
            currData.maxSpeed = (char)2;
        }

        if (nearEnemyCount >= 2)
        {
            currData.eDistance = EnemyDistance.NEAR;
        }
        else
        {
            currData.eDistance = EnemyDistance.FAR;
        }

        //quantize distance and classify it into NEAR, FAR
        //currData.eDistance = EnemyDistance.FAR; //removed this< via commenting<< such><YKWIM>> out here> ...in favour of existing code that classifies such <<above><YKWIM>><< with a nearEnemyCount><YKWIM>> value

        #region noting of determining action - with noting of this and not used within Using as the action would be generated rather than retrieved

        //get attack and classify it ...

        //classification of whether the AI would be doing an "attacking" behaviour - which would just be shooting and maybe approaching, "Wander" behaviour - which would be having been moving sideways towards enemies <<if not alternatingly towards and away from enemies, noting of how such would be done in terms of such, noting of eg. <<rather large><YKWIM>> <<amounts of><YKWIM>> movement that would yield a <<low><YKWIM>> difference in distance from enemies><YKWIM>>, or "Retreat" behaviour - which would be moving away from enemies
        //where such of moving away from enemies would be in increasing the distance between the closest enemy, or increasing the average distance from the closest 2 enemies
        //with comparison with 2 seconds before, or 120 frames before, with noting of eg. positions tracked of eg. enemies in the past 120 frames and\or distances of such enemies from the player in the past 180 frames ... with eg. a queue storing such distances of each frame ... or keeping track of the past 180 frames ...
        //Queue<float> avgClosest2eDistances = new Queue<float>(); //across 180F

        //though could note of how the difference could be due to just the enemies moving and not necessarily the player moving; could note this as a <<super simplification><YKWIM>>

        currData.AIAction = Action.Attack; //set in order to avoid Visual Studio <<from ><YKWIM>>displaying an "error" due to lack of initialization
        float distanceDiff = 0;
        float prevDistance = 0; //made for debugging; otherwise could do without this var
        if (avgClosest2eDistances.Count >= 180)
        {
            //can compare the 180f prior with the curr.
            prevDistance = avgClosest2eDistances.Dequeue();
            distanceDiff = avgEnemyDistanceOfClosest2 - prevDistance;
        }
        else
        {
            if (avgClosest2eDistances.Count > 0)
            {
                prevDistance = avgClosest2eDistances.Peek();
            }
            distanceDiff = avgEnemyDistanceOfClosest2 - /*((avgClosest2eDistances.Count > 0)?avgClosest2eDistances.Peek() : 0f)*/prevDistance; //get the earliestmost unit of data
        }
        //Debug.Log("curr dist: " + avgEnemyDistanceOfClosest2 + ", prev dist: " + prevDistance+"; distanceDiff: "+distanceDiff);
        if (distanceDiff > 1)
        {
            //consider such an amount of positive difference as retreat
            currData.AIAction = Action.Retreat;
        }
        else if (distanceDiff > -1)
        {
            //consider such a small \ nonexistent difference as wander
            currData.AIAction = Action.Wander;
        }
        else
        {
            //consider such an amount of negative difference as attack
            currData.AIAction = Action.Attack;
        }
        #endregion
        avgClosest2eDistances.Enqueue(avgEnemyDistanceOfClosest2);

        currData.avgClosest2EnemyPosn = avgEnemyPosOfClosest2;
        return currData;
    }


    void Training()
    {
        //Get state of enemy positions and 'player action'<< - with 'player action' being just the difference in distance in frames><YKWIM>>
        Vector2 playerPos = GameObject.FindGameObjectWithTag("Player").transform.position; //the position of the player for training
        MarkovUnit currData = getData(playerPos, true); //noting of not being able to pass an empty struct to the function, so not being able to pass <<a null><YKWIM>> MarkovUnit<< as an argument to be modified and\or such><YKWIM>>

        bool isAlsoCycling = false; //made so that such code would not run, in noting of testing game on mobile and such and preventing such computations
        bool isDoingDistributionOfCycles = false;
        bool isDoingDistributionOfFixedRelativeMovementVecCycles = true;

        //SHMM feature combination and generation data, encoded as strings
        string featureStr = "";
        string genStr = "";

        //convert the data of prev. movement dirs relative to SM and M-N into strings, from oldest movement dirs to newest
        string prevMovementRelativeToCMAndMNStr = "";
        while(currData.QuantizedDirAngle_RelativeToCMAtData.Count > 0/* && (prevMovementRelativeToCMAndMNStr.Length <= 4) in case the string would have copied more than MAX_PREVDIRS * 2 chars somehow*/)
        {
            prevMovementRelativeToCMAndMNStr += currData.QuantizedDirAngle_RelativeToCMAtData.Dequeue(); //getting the oldest prev. data first
            prevMovementRelativeToCMAndMNStr += currData.QuantizedDirAngle_RelativeToMNAtData.Dequeue();
        }
        prevMovementRelativeToCMAndMNStr = prevMovementRelativeToCMAndMNStr.PadLeft(MAX_PREVDIRS * 2, '0'); //padding with the max length for dirs

        featureStr += ((char)(currData.eDistance + '0')) + "" + ((char)(currData.maxSpeed + '0'))/* plus previous 3 movement vectors in terms of the relative direction from the <<'CM' and 'M-N' positions - with such directions as <<quantized angles><YKWIM>> relative to such 'CM' and 'M-N' positions><YKWIM>>*/ + prevMovementRelativeToCMAndMNStr;
        genStr += ((char)(currData.AIAction + '0'));

        //reset the currTrainingCycle if just loaded data, or swapped places with a Shadow - noting of such and only resetting such of SHMMDataOrdered3, with noting of how well that this would work for other <wrtxtlater: types of >cycles - with TODO<wrtxtlater: <wrtxtlater:  if such would be TODO> as of 12/23/18>: any of having this resetting work for other types of cycles
        if(resetCurrTrainingCycle_withLoadedDataThisUpdate || SwappedPlacesThisUpdate)
        {
            SHMMDataOrdered3_currTrainingCycle_featureStr = featureStr;
            SHMMDataOrdered3_currTrainingCycle = new List<Pair<genBehaviourData, float>>();
            Debug.Log("training cycle reset");
        }
        if(resetCurrTrainingCycle_withLoadedDataThisUpdate)
        {
            resetCurrTrainingCycle_withLoadedDataThisUpdate = false;
        }
        if (SwappedPlacesThisUpdate)
        {
            //also reset the movement timer for the cycle alongside the prior resetting of the currTrainingCycle <with any TODO as of 12/<rmtxthere: 3/>23/18 of making this resetting work for other types of cycles of such would be TODO>, with any
            //and reset whatever else could be based on the previous environment / features and/or such, including the prev dir queues as well and any other queues, such as avgClosest2eDistances
            prevMovementDirTimer = 0f; //not setting prevMovementDirTimer to prevMovementDirInterval because of resetting eg. featureStr and/or such being already done in the prior if statement
            QuantizedDirAngle_RelativeToCM.Clear();
            QuantizedDirAngle_RelativeToMN.Clear();
            avgClosest2eDistances_player.Clear();
            avgClosest2eDistances_nonplayer.Clear();
            SwappedPlacesThisUpdate = false;
        }

        //bool isTrainingCyclingOnly = true;

        //add to probability distribution map - add weight to the feature and generation combination
        if (!SHMMData.ContainsKey(featureStr))
        { //initialize if not already done
            SHMMData[featureStr] = new Dictionary<string, int>();

            if (isAlsoCycling)
            {
                SHMMData_maintainOrder[featureStr] = new List<KeyValuePair<string, int>>();
            }
            SHMMData_ofmaintainOrderCycles[featureStr] = new List<List<KeyValuePair<string, int>>>();
        }
        if(!SHMMDataOrdered3_ofFixedLengthCycles.ContainsKey(featureStr)) //in case that SHMMData would be having elements that SHMMDataOrdered3_ofFixedLengthCycles would not, separating these
        {
            SHMMDataOrdered3_ofFixedLengthCycles[featureStr] = new List<List<Pair<genBehaviourData, float>>>();
        }
        if (!SHMMData[featureStr].ContainsKey(genStr)) //initialize if not already done
        {
            SHMMData[featureStr][genStr] = 0;
        }
        SHMMData[featureStr][genStr] += 1; //add 1 to the weight for the generation found within the generation probability distribution <<given the feature combination><YKWIM>>

        //Code for adding to SHMMData_maintainOrder
        //create new list item for genStr if not already the last list item; otherwise add 1 to the last list item
        #region isAlsoCycling
        if (isAlsoCycling)
        {
            KeyValuePair<string, int> LastSHMMData;
            bool SHMMDistributionIsEmpty = SHMMData_maintainOrder[featureStr].Count <= 0;
            if (!SHMMDistributionIsEmpty)
            {
                LastSHMMData = SHMMData_maintainOrder[featureStr].Last();
                if (LastSHMMData.Key == genStr) //just increment weight if last weight
                {
                    SHMMData_maintainOrder[featureStr][SHMMData_maintainOrder[featureStr].Count - 1] = new KeyValuePair<string, int>(genStr, LastSHMMData.Value + 1); //Last() not allowing reassignment
                }
                else //add new list item with different genStr if not
                {
                    SHMMData_maintainOrder[featureStr].Add(new KeyValuePair<string, int>(genStr, 1)); //add new element
                }
            }
            else
            {
                SHMMData_maintainOrder[featureStr].Add(new KeyValuePair<string, int>(genStr, 1)); //alongside initializing, adding first element to the List
            }
        }
        #endregion
        //Code for adding to SHMMData_ofmaintainOrderCycles
        //Add to SHMMDataOrdered2_currCycle until complete, then add to the distribution for the corresponding featureStr
        bool newCycleOrGenStr = false; //for detecting new feature or generation changes
        #region isDoingDistributionOfCycles
        if (isDoingDistributionOfCycles)
        {
            if (featureStr != SHMMDataOrdered2_currTrainingCycle_featureStr || SHMMDataOrdered2_currTrainingCycle_Length >= SHMMDataOrdered2_cycleLengthLimit) //One cycle for each period of the entirety of while the feature value set would be unchanged; new featureStr - start new cycle
            {
                if(SHMMDataOrdered2_currTrainingCycle_featureStr != "") //if not the initial str (i.e. before any cycle would have been started being created), then add the currCycle
                {
                    SHMMData_ofmaintainOrderCycles[SHMMDataOrdered2_currTrainingCycle_featureStr].Add(SHMMDataOrdered2_currTrainingCycle);
                    //Debug.Log("Adding new training cycle; last gen before addition w: " + SHMMDataOrdered2_currTrainingCycle.Last().Value);
                }
                SHMMDataOrdered2_currTrainingCycle_featureStr = featureStr;
                SHMMDataOrdered2_currTrainingCycle = new List<KeyValuePair<string, int>>();
                SHMMDataOrdered2_currTrainingCycle_Length = 0;
                newCycleOrGenStr = true;
            }

            //create new list item for SHMMDataOrdered2_currTrainingCycle if not already the last list item; otherwise add 1 to the last list item
            KeyValuePair<string, int> LastSHMMData;
            bool CycleIsEmpty = SHMMDataOrdered2_currTrainingCycle.Count <= 0;
            if (!CycleIsEmpty)
            {
                LastSHMMData = SHMMDataOrdered2_currTrainingCycle.Last();
                if (LastSHMMData.Key == genStr) //just increment weight if last weight
                {
                    SHMMDataOrdered2_currTrainingCycle[SHMMDataOrdered2_currTrainingCycle.Count - 1] = new KeyValuePair<string, int>(genStr, LastSHMMData.Value + 1); //Last() not allowing reassignment
                }
                else //add new list item with different genStr if not
                {
                    //Debug.Log("Adding new generation with a different genStr; last gen before addition w: " + LastSHMMData.Value);
                    SHMMDataOrdered2_currTrainingCycle.Add(new KeyValuePair<string, int>(genStr, 1)); //add new element
                    //Debug.Log("Starting with adding new generation for: " + debugStr_act[(Action)(genStr[0] - '0')]);
                    newCycleOrGenStr = true;
                }
            }
            else
            {
                SHMMDataOrdered2_currTrainingCycle.Add(new KeyValuePair<string, int>(genStr, 1)); //alongside initializing, adding first element to the List
            }
            SHMMDataOrdered2_currTrainingCycle_Length++; //increment current training cycle length by 1
        }
        #endregion
        if(isDoingDistributionOfFixedRelativeMovementVecCycles)
        {
            if (resetMovementDirTimerThisUpdate) //One cycle for each period of the entirety of while the current interval for the respective time has not changed; new interval (with timer having been reset) - start new cycle with the current featureStr
            {
                if (SHMMDataOrdered3_currTrainingCycle_featureStr != "") //if not the initial str (i.e. before any cycle would have been started being created), then add the currCycle
                {
                    SHMMDataOrdered3_ofFixedLengthCycles[SHMMDataOrdered3_currTrainingCycle_featureStr].Add(SHMMDataOrdered3_currTrainingCycle);
                    //Debug.Log("Adding new training cycle"/* + SHMMDataOrdered3_currTrainingCycle.Last().Value*/);
                }
                SHMMDataOrdered3_currTrainingCycle_featureStr = featureStr;
                SHMMDataOrdered3_currTrainingCycle = new List<Pair<genBehaviourData, float>>();
                newCycleOrGenStr = true;
            }
            //if(!FireShot.playerIsFiring)
            //{
            //    Debug.Log("playerIsFiring is "+FireShot.playerIsFiring);
            //}
            genBehaviourData genData = new genBehaviourData()
            {
                movement_thisUpdate_CWAngleRelativeToSMPos = currData.movementDir_thisUpdate_CWAngleRelativeToSMPos,
                movement_thisUpdate_CWAngleRelativeToMNPos = currData.movementDir_thisUpdate_CWAngleRelativeToMNPos,
                movement_thisUpdate_Magnitude = currData.movementDir_thisUpdate_Magnitude,
                isFiring_thisUpdate = FireShot.playerIsFiring
            };

            if (genData.movement_thisUpdate_CWAngleRelativeToMNPos == 0)
            {
                Debug.Log("CWAngleRelativeToMNPos is 0 in Training() outside of the getData method right now");
            }

            //create new list item for SHMMDataOrdered3_currTrainingCycle
            //SHMMDataOrdered3_currTrainingCycle.Add(new Pair<genMovementData, float>(genData, Time.fixedDeltaTime)); //alongside initializing, adding first element to the List

            //create new list item for SHMMDataOrdered3_currTrainingCycle if not already (equal to) the last list item; otherwise add Time.fixedDeltaTime to the last list item
            Pair<genBehaviourData, float> LastSHMMData;
            bool CycleIsEmpty = SHMMDataOrdered3_currTrainingCycle.Count <= 0;
            if (!CycleIsEmpty)
            {
                LastSHMMData = SHMMDataOrdered3_currTrainingCycle.Last();
                if (LastSHMMData.First.Equals(genData)) //just increment weight if last weight
                {
                    SHMMDataOrdered3_currTrainingCycle[SHMMDataOrdered3_currTrainingCycle.Count - 1].Second = LastSHMMData.Second + Time.fixedDeltaTime; //Last() not allowing reassignment
                }
                else //add new list item with different genData if not (equal to) last list item
                {
                    //Debug.Log("Adding new generation with a different genStr; last gen before addition w: " + LastSHMMData.Second);
                    SHMMDataOrdered3_currTrainingCycle.Add(new Pair<genBehaviourData, float>(genData, Time.fixedDeltaTime)); //add new element
                    //Debug.Log("Starting with adding new generation for: " + debugStr_act[(Action)(genStr[0] - '0')]);
                    newCycleOrGenStr = true;
                }
            }
            else //if not (equal to, with what I would mean by "equal to" here) last list item (being with the cycle being empty)
            {
                SHMMDataOrdered3_currTrainingCycle.Add(new Pair<genBehaviourData, float>(genData, Time.fixedDeltaTime)); //alongside initializing, adding first element to the List
            }
        }

        ////add to probability distribution map

        //if (newCycleOrGenStr/*!genStr.Equals(prevGenStr_training) || currData.eDistance != preveDistance || currData.maxSpeed != prevMaxSpeed*/) //do things with selectedGenStr<< if there would be a difference from the prev. generation string><YKWIM>>
        //{
        //    //Debug.Log("total of weights: " + totalOfWeights + "; selected weight: " + selWeightValue); //some testing
        //    //prevGenStr_training = genStr;
        //    //preveDistance = currData.eDistance;
        //    //Debug.Log("selectedGenStr: "+selectedGenStr);
        //    Action ChangedAIActionNum = (Action)(genStr[0]/* - read as a char?*/ - '0'); //with AI action with index 0
        //    string featureText = "";
        //    switch (currData.eDistance)
        //    {
        //        case EnemyDistance.NEAR:
        //            featureText = "NEAR";
        //            break;
        //        case EnemyDistance.FAR:
        //            featureText = "FAR";
        //            break;
        //    }

        //    switch (ChangedAIActionNum)
        //    {
        //        case Action.Retreat:
        //            Debug.Log("Player now on " + featureText + ", Retreat");
        //            break;
        //        case Action.Attack:
        //            Debug.Log("Player now on " + featureText + ", Attack");
        //            break;
        //        case Action.Wander:
        //            Debug.Log("Player now on " + featureText + ", Wander");
        //            break;
        //    }
        //    //Debug.Log("Shadow AI nearby enemy count: " + (int)newAIMarkovUnit.neCount);
        //    Debug.Log("Player nearby enemy max speed: " + (int)currData.maxSpeed);


        //    //noting of such of <<Shadow AIs><YKWIM>> and how the behaviour would be implemented for each of such as well
        //}

        //Noting of weights and basically adding a weight where the fraction of the weight would be its probability of being triggered by the AI and\or such as a transition ...
        //noting of how eg. such would preserve the Markov data in a lot of frames ... noting of eg. how such would be probabilistic rather than eg. <<moreso periodic and\or such><YKWIM>>
        prevMarkovData1 = currData;
    }

    void Using()
    {
        // Randomly generate words that resemble the words in the dictionary.
        var rand = new System.Random();

        //get features and actions of the current feature combination, as stored in ...well, stored in <<what was CurrAIPrevMarkovUnit><YKWIM>> <<with features as set><YKWIM>>

        //get <<next action><YKWIM>>
        //regarding <<"get <<next action><YKWIM>>" above< - as part of such>: ><YKWIM>>retrieve <<features from game state><YKWIM>>

        Vector2 shadowPos = transform.position;
        MarkovUnit currData = getData(shadowPos, false); //position of the Shadow for use //get current data, for the features


        //convert the data of prev. movement dirs relative to SM and M-N into strings, from oldest movement dirs to newest
        string prevMovementRelativeToCMAndMNStr = "";
        while (currData.QuantizedDirAngle_RelativeToCMAtData.Count > 0/* && (prevMovementRelativeToCMAndMNStr.Length <= 4) in case the string would have copied more than MAX_PREVDIRS * 2 chars somehow*/)
        {
            prevMovementRelativeToCMAndMNStr += currData.QuantizedDirAngle_RelativeToCMAtData.Dequeue(); //getting the oldest prev. data first
            prevMovementRelativeToCMAndMNStr += currData.QuantizedDirAngle_RelativeToMNAtData.Dequeue();
        }
        prevMovementRelativeToCMAndMNStr = prevMovementRelativeToCMAndMNStr.PadLeft(MAX_PREVDIRS * 2, '0'); //padding with the max length for dirs

        //SHMM feature combination and generation data, encoded as strings
        string featureStr = "";
        featureStr += ((char)(currData.eDistance + '0')) + "" + ((char)(currData.maxSpeed + '0')) + prevMovementRelativeToCMAndMNStr;

        //reset the currTrainingCycle if just loaded data
        if (resetCurrUsingCycle_withLoadedDataThisUpdate || SwappedPlacesThisUpdate) //with TODOs <as of 12/23/18<rmtxthere: , >> as with those seen in Training() <as I would be aware<< and\or such><YKWIM>>>
        {
            //SHMMDataOrdered3_currTrainingCycle_featureStr = featureStr;
            //SHMMDataOrdered3_ofFixedLengthCycles[featureStr][randCycleIndex];
            SHMMDataOrdered3_currUsingCycle = new List<Pair<genBehaviourData, float>>(); //dummy
            SHMMDataOrdered3_currUsingCycle.Add(new Pair<genBehaviourData, float>(new genBehaviourData(), 0f)); //dummy that would be to be replaced
            SHMMDataOrdered3_cyclePosn = Tuple.Create<int, float>(0, 0f); //in order to prevent index out of bounds errors
            Debug.Log("Using cycle reset");
        }
        if (resetCurrTrainingCycle_withLoadedDataThisUpdate)
        {
            resetCurrUsingCycle_withLoadedDataThisUpdate = false;
        }
        if (SwappedPlacesThisUpdate) //with TODOs <as of 12/23/18> as with those seen in <wrtxtlater: Training()><rmtxthere: Training> <as I would be aware<< and\or such><YKWIM>>>
        {
            prevMovementDirTimer = 0f; //not setting prevMovementDirTimer to prevMovementDirInterval because of resetting eg. featureStr and/or such being already done in the prior if statement
            QuantizedDirAngle_RelativeToCM.Clear();
            QuantizedDirAngle_RelativeToMN.Clear();
            avgClosest2eDistances_player.Clear();
            avgClosest2eDistances_nonplayer.Clear();
            SwappedPlacesThisUpdate = false;
        }

        //if feature combination is not present, then do nothing <<regarding the genStr, etc.><YKWIM>>
        if (SHMMData.ContainsKey(featureStr))
        {
            int selWeightValue = 0; //with initial value to be changed if used - i.e. when isCycling would be false, as of 9/15/18, 2:55PM
            #region Planning for SHMM
            //Todo? as of 9/13/18, 11:<removed text here of: 14>45PM<< with such started@11:44PM regarding this todo <removed text here: of w>being started><-nmn>>: Periodic cycling of SHMM weights in the learning involved
            //with noting of such periodic cycling and how generation would be designed based on such
            //<<implementation of periodic cycling of behaviours, with gaussian distributions for each interval of each period, as what could be todo><YKWIM>>

            #region About part of normal distribution implementation
            //get z-score for a distribution, in a weighted random selection accordingly to the weights in a normal disribution
            //double randVal = rand.NextDouble(); //percentile, or one-tailed p-value
            //double z_score = MathNet.Numerics.Distributions.StudentT.InvCDF(0, 1, 99999, randVal);
            //TODO as of 9/15/18: get corresponding sample value (at least as if) from normal distribution of given behaviour interval samples, i.e.: mean + SD*z_score
            #endregion
            //SHMM implementation of random selections in distributions of: cycles of periodic behaviour ?
            //  -both within the SHMM, with random selection of: 
            //      -'period data structures'
            //      -some of SHMM data?
            //          -basically data for generation of SHMMData_maintainOrder as a generation - as a 'period data structure' - randomly selected in the distributions of SHMMData?
            //          with such a number of possibilities of periods of such SHMMData_maintainOrder but such data stored as how such would be of Lists of periods and durations with such generation possibilities
            //              -though noting of how such periods would be selected among the closest training data point/training data points? to the corresponding enemy speed and distance, with such features? 
            //              Well, noting of such of being among the existing 'tiers' already and maybe doing such <<use of 'inferred usual cases'><YKWIM>> to be more precise to the data points ... or making use of other data <<i.e. feature data, OR <different <<feature types> or <'inferred usual cases'>>>><YKWIM>> if necessary ...
            //                  -with noting of if <<eg. using all feature data and making 'inferred usual cases' for each individual <feature value set> <where all of the feature data would be taken into account in doing so> and <<'breaking the paradigm of the SHMM' if so><YKWIM>> <and 
            //                      noting of <<if such would be considered as <machine learning \ ><a conventional method of machine learning>><YKWIM>>>><YKWIM>>
            #region About being within specs
            //          with noting of such and how such would be done and being within the specifications as covered in my project proposal and my e-mails to Aaron Hunter
            //          with this as written in said e-mails: "I was also thinking of making some changes to the existing machine learning - in particular, modifying it to accommodate learning 'periodic' player behaviour (as opposed to just treating behaviour as random and imitating behaviour randomly (though weighted by frequencies of behaviour)): 
            //          ...Or as an alternative approach I was thinking of instead, there could be - as one of the hard-coded generated behaviours of the game's Shadow AI (that would be one behaviour among the SHMM's behaviour probability distribution) - a learning of periodic movement behaviour intervals implemented additionally to the SHMM. This learning would be separate from that of the probability distributions of the SHMM."
            //          And could note how such would be said with learning as separate from that of the SHMM's probability distributions - where I could note of how such would be separate from the probability distribution learning algorithm for learning probability distributions, but such being with said learning being for what would be among things that could be selected in the said probability distributions - but also as one behaviour among the SHMM's behaviour probability distribution, with noting of such and consistency with such of the planned design to be implemented
            //          and could note of such of if such would be within such as described, with such in my e-mails and such with 'taking such written to be meant a certain way' in my e-mails to Aaron Hunter on doing such - with noting of the meaning of 'separate' with being 'distinct' - 'different in nature' while being mentioned as 'one behaviour ...' \ the meaning of "being or standing apart; distant or dispersed" where "apart" would mean "to or at one side, with respect to place, purpose, or function" and where "side" would mean 
            //              -"an aspect or phase, especially as contrasted with another aspect or phase" or 
            //              -something else if there would be another meaning of "side" that could also be used to fit the meaning of what I would be intending for the AI's design to be implemented
            //          as seen on dictionary.com
            #endregion//
            //      
            //
            //Copying of periods of data and modifying such periods in terms of their retreat\non-retreat durations with such as extrapolations from said data to what would be seen in the current game environment ...at: 
            //  -the current instant, 
            //  or at 
            //  -the start of the period, or ...
            //with noting of such with being modifications of the periods of copied periodic cycles
            //with maybe such of the current environment leading to different 'speeds' \ 'time rates' for such periods of eg. retreat and non-retreat within the current cycle
            //
            #region Data extrapolation functionality/formula
            //Functionality for extrapolation of data
            //Formula for retreat:non-retreat ratio given enemy distance and speed
            //(that would be able to determine amt. time for enemies to reach player if the player were still, and 
            //amt. time for enemies to reach player if the player would be moving away
            //with whatever of such of the two just-aforementioned times would be a part of the formula for such a retreat:non-retreat ratio I would make if so)
            //
            //where if speed would be less than player's, 
            //ratio_data + (distance / speed - distance_data / speed_data) * (some constant factor for conversion of distance/speed to corresponding ratio difference, which could be obtained from data, for a linear relationship between such a ratio and such of distance/speed)
            //
            //and if speed would be greater than player's, 
            //fasterratio_data + (distance / speed - distance_data / speed_data) * (some - different for such greater-than-player enemy speeds - constant factor for conversion of distance/speed to corresponding ratio difference, which could be obtained from data, for a linear relationship between such a ratio and such of distance/speed
            //with noting of how amt. time for enemies to reach a player that would be moving away could be made into a part of this formula as well, or just using such of different data use being enough, though noting of amt. retreating being maybe moreso linearly related to such of enemies' speed relative to the player with the player maybe moving away moreso and noting of health of the enemy ... though 
            //if such of health would not be accounted for, noting of such and handling eg. the expected health of such enemies with such a distance and speed)
            #endregion
            #endregion

            bool isCycling = false;
            bool isDoingDistributionOfCycles = false;
            bool isDoingDistributionOfFixedRelativeMovementVecCycles = true;
            if (isCycling)
            {
                #region isCycling code
                //increment selWeightValue for the given feature set ...or, use SHMMDataOrdered_cyclePosn for the value instead, which would be used to obtain the selectedGenStr
                //noting of the order of each value's weight obtained, with noting of such of the distribution and to be in the same order as obtained during training, rather than <<weight values><YKWIM>> just placed into 'buckets' and noting of modification of the SHMM accordingly to track such, with making values of each feature set into a List instead of a Dictionary
                //keeping track of the current List element index and weight of the element in SHMMData_maintainOrder as the cyclePosn

                //if ()
                int SHMMDataIndex = SHMMDataOrdered_cyclePosn[featureStr].Item1;
                int SHMMDataWeightPos = SHMMDataOrdered_cyclePosn[featureStr].Item2;
                if (SHMMDataWeightPos >= SHMMData_maintainOrder[featureStr][SHMMDataIndex].Value) //if position is at the last weight value (or later or somehow)
                {
                    //go to next element of List or cycle back if it is the last element
                    if (SHMMDataIndex >= SHMMData_maintainOrder[featureStr].Count - 1)
                    {
                        SHMMDataIndex = 0;
                    }
                    else
                    {
                        SHMMDataIndex++;
                    }
                }
                else
                {
                    SHMMDataWeightPos++;
                }

                SHMMDataOrdered_cyclePosn[featureStr] = Tuple.Create<int, int>(SHMMDataIndex, SHMMDataWeightPos)/*(SHMMData_cyclePosn[featureStr] + 1) % totalOfWeights*/; //increment by weight, where one weight val would be obtained each frame in training, and so doing the same in using
                                                                                                                                                                           //selWeightValue = SHMMData_cyclePosn[featureStr];
                #endregion
            }
            #region isDoingDistributionOfCycles
            else if(isDoingDistributionOfCycles)
            {
                //implementation to be done when with a new featureStr
                //with allowing completion of the cycle up to a time limit ...actually, already handled ...actually, current way of handling would not make the first condition using SHMMDataOrdered2_currUsingCycle to use the current featureStr, but the last featureStr ... though that being what would be intended in the design
                //SHMMDataOrdered2_currUsingCycle

                int SHMMDataIndex = SHMMDataOrdered2_cyclePosn.Item1;
                int SHMMDataWeightPos = SHMMDataOrdered2_cyclePosn.Item2;
                if (SHMMDataWeightPos >= SHMMDataOrdered2_currUsingCycle[SHMMDataIndex].Value) //if position is at the last weight value (or later or somehow)
                {
                    //go to next element of List or re-select a new cycle for the given featureStr if it is the last element
                    if (SHMMDataIndex >= SHMMDataOrdered2_currUsingCycle.Count - 1) //if end of cycle
                    {
                        SHMMDataIndex = 0;
                        int randCycleIndex = rand.Next(SHMMData_ofmaintainOrderCycles[featureStr].Count);
                        SHMMDataOrdered2_currUsingCycle = SHMMData_ofmaintainOrderCycles[featureStr][randCycleIndex]; //re-selection of cycle
                    }
                    else
                    {
                        SHMMDataWeightPos -= SHMMDataOrdered2_currUsingCycle[SHMMDataIndex].Value;
                        SHMMDataIndex++;
                    }
                }
                else
                {
                    SHMMDataWeightPos++;
                }

                SHMMDataOrdered2_cyclePosn = Tuple.Create<int, int>(SHMMDataIndex, SHMMDataWeightPos)/*(SHMMData_cyclePosn[featureStr] + 1) % totalOfWeights*/; //increment by weight, where one weight val would be obtained each frame in training, and so doing the same in using
            }
            #endregion
            if (isDoingDistributionOfFixedRelativeMovementVecCycles)
            {
                //implementation to be done when with a new featureStr
                //with allowing completion of the cycle up to a time limit ...actually, already handled ...actually, current way of handling would not make the first condition using SHMMDataOrdered3_currUsingCycle to use the current featureStr, but the last featureStr ... though that being what would be intended in the design

                int SHMMDataIndex = SHMMDataOrdered3_cyclePosn.Item1;
                float SHMMDataWeightPos = SHMMDataOrdered3_cyclePosn.Item2;
                if (SHMMDataWeightPos >= SHMMDataOrdered3_currUsingCycle[SHMMDataIndex].Second) //if position is at the last weight value (or later or somehow)
                {
                    //re-select a new cycle for the given featureStr if (it is the last element or timer resets), or <<otherwise><YKWIM>> go to next element of List
                    if (resetMovementDirTimerThisUpdate || SHMMDataIndex >= SHMMDataOrdered3_currUsingCycle.Count - 1) //if reset timer with the interval, or end of cycle
                    {
                        SHMMDataIndex = 0;

                        //set new cycle if one exists
                        //Debug.Log("reset cycle");
                        if (SHMMDataOrdered3_ofFixedLengthCycles.ContainsKey(featureStr)/* - where this here was removed \ <<was an original version><YKWIM>>: SHMMDataOrdered3_ofFixedLengthCycles[featureStr] != null*/ && SHMMDataOrdered3_ofFixedLengthCycles[featureStr].Count >= 1)
                        {
                            int randCycleIndex = rand.Next(SHMMDataOrdered3_ofFixedLengthCycles[featureStr].Count);
                            SHMMDataOrdered3_currUsingCycle = SHMMDataOrdered3_ofFixedLengthCycles[featureStr][randCycleIndex]; //re-selection of cycle
                            //Debug.Log("new Using cycle set");
                        }
                    }
                    else
                    {
                        SHMMDataWeightPos -= SHMMDataOrdered3_currUsingCycle[SHMMDataIndex].Second;
                        SHMMDataIndex++; //go to next element of List
                    }
                }
                else
                {
                    SHMMDataWeightPos += Time.fixedDeltaTime;
                }

                //go to next element of List or re-select a new cycle for the given featureStr if it is to reset at this point
                //if (resetMovementDirTimerThisUpdate)
                //{
                //    SHMMDataIndex = 0;
                //    int randCycleIndex = rand.Next(SHMMDataOrdered3_ofFixedLengthCycles[featureStr].Count);
                //    SHMMDataOrdered3_currUsingCycle = SHMMDataOrdered3_ofFixedLengthCycles[featureStr][randCycleIndex];
                //}
                SHMMDataOrdered3_cyclePosn = new Tuple<int, float>(SHMMDataIndex, SHMMDataWeightPos)/*(SHMMDataIndex+1) % (SHMMDataOrdered3_currUsingCycle.Count)*//*(SHMMData_cyclePosn[featureStr] + 1) % totalOfWeights*/; //increment by weight, where one weight val would be obtained each frame in training, and so doing the same in using
            }
            else
            {

                var totalOfWeights = SHMMData[/*feature string*/featureStr].Sum(w => w.Value);// <<with TODO as of 7/8/18, 10:06PM< - later than a prior 10:06PM on 7/8/18 written> <elsewhere>><YKWIM>><< - and as of 8/14/18, 2:58PM, noting of if such a TODO would still be a TODO, with noting of any completion of such><YKWIM>>
                selWeightValue = rand.Next(totalOfWeights) + 1/* - with the + 1 being ... in being <<'up to' that weight integer rather than <up to ((the weight integer)-1<, where 0 would not be a possible value to be checked, with addition of a weight before <<checking of the total current weight against the value>><YKWIM>>)>><YKWIM>>*/; //value selected among the weights
            }


            string selectedGenStr = "9"; //generation that would have been <randomly >selected among the <<distribution of weights><YKWIM>><< - being part of a probability distribution><YKWIM>> //set to a dummy value that would be intended as "n/a" behaviour of the Shadow AI

            #region isCycling code
            if (isCycling)
            {
                //get selectedGenStr from this cycled version instead
                int SHMMDataIndex = SHMMDataOrdered_cyclePosn[featureStr].Item1;
                selectedGenStr = SHMMData_maintainOrder[featureStr][SHMMDataIndex].Key;
            }
            #endregion
            else if (isDoingDistributionOfCycles) //!isCycling
            {
                //get selectedGenStr from this cycled version instead
                int SHMMDataIndex = SHMMDataOrdered2_cyclePosn.Item1;
                selectedGenStr = SHMMDataOrdered2_currUsingCycle[SHMMDataIndex].Key;
                //Debug.Log("SHMMDataOrdered2_currUsingCycle[SHMMDataIndex].Key: " + SHMMDataOrdered2_currUsingCycle[SHMMDataIndex].Key);
            }
            else if (isDoingDistributionOfFixedRelativeMovementVecCycles)
            {
                //int SHMMDataIndex = SHMMDataOrdered3_cyclePosn;
                //selectedGenStr = SHMMDataOrdered3_currUsingCycle[SHMMDataIndex];
                selectedGenStr = ""; //selectedGenStr not used for this
            }
            else
            {
                var currentWeight = 0;
                foreach (var nextItem in SHMMData[featureStr]) //iterate through the weights and select the first <<item><YKWIM>> that would <<reach the ><YKWIM>><<random value threshold><YKWIM>> to add to the state
                {
                    currentWeight += nextItem.Value;
                    if (currentWeight >= selWeightValue) //selected item <<at the value><YKWIM>>
                    {
                        selectedGenStr = nextItem.Key;
                        break;
                    }
                }
            }

            //parse <<generation str><YKWIM>> into generation <<enums and\or such><YKWIM>>
            //if (!selectedGenStr.Equals(prevGenStr)) //do things with selectedGenStr<< if there would be a difference from the prev. generation string><YKWIM>>
            //{
            //    //Debug.Log("total of weights: " + totalOfWeights + "; selected weight: " + selWeightValue); //some testing
            //    prevGenStr = selectedGenStr;
            //    //Debug.Log("selectedGenStr: "+selectedGenStr);
            //    Action ChangedAIActionNum = (Action)(selectedGenStr[0]/* - read as a char?*/ - '0'); //with AI action with index 0
            //    string featureText = "";
            //    switch (currData.eDistance)
            //    {
            //        case EnemyDistance.NEAR:
            //            featureText = "NEAR";
            //            break;
            //        case EnemyDistance.FAR:
            //            featureText = "FAR";
            //            break;
            //    }

            //    switch (ChangedAIActionNum)
            //    {
            //        case Action.Retreat:
            //            Debug.Log("Shadow AI now on " + featureText + ", Retreat");
            //            break;
            //        case Action.Attack:
            //            Debug.Log("Shadow AI now on " + featureText + ", Attack");
            //            break;
            //        case Action.Wander:
            //            Debug.Log("Shadow AI now on " + featureText + ", Wander");
            //            break;
            //    }
            //    //Debug.Log("Shadow AI nearby enemy count: " + (int)newAIMarkovUnit.neCount);
            //    Debug.Log("Shadow AI nearby enemy max speed: " + (int)currData.maxSpeed);


            //    //noting of such of <<Shadow AIs><YKWIM>> and how the behaviour would be implemented for each of such as well
            //}

        }

        //Any of executing the corresponding generated behaviour
        //noting of such and any distribution of such and how such generated behaviours could coexist, and such vs. eg. other distributions and\or such
        //with noting of how such would be distributed by players, with eg. being by frame \ by some other <<'block'><YKWIM>>

        #region Some about generation design/implementation
        //noting of maybe some gradual acceleration towards different directions and eg. target velocities eg. relative to enemies for each of the generated behaviours, with such ... though noting what would be possible with noting of 'gradual acceleration' for a Shadow, with inputs ... with noting of 'humanlike' inputs with such distributions ... with noting of eg. 'periodic patterns' in inputs rather than just probabilistic of such patterns
        //with noting of if such of an SHMM could be used with its weights for lengths of periods of different behaviours, rather than as a probability distribution
        //with noting of eg. any of such probability distributions in 're-outputting to some group of 'buckets' whose contained values would be periods of each behaviour periodically cycled through'
        //and such as basically transferring such weight values to such periodic data if such would be done
        //with noting of if such of such data of an SHMM could be used in such a way - with such weights as proportional to period lengths instead of probabilities and directly using such in a way, and if such would be: 
        //  -something that could be approved in a proposal for machine learning
        //  -something that my current proposal could have as allowed
        //with noting of eg. if such could be done as something that Aaron Hunter could approve <<and\or such><YKWIM>> <<of such a way of using SHMMs in such a way and\or re-purposing such 'SHMMs' as whatever such a model would be, with such and what would be considered as machine learning with such><YKWIM>>
        //noting of if eg. such would be considered as a Markov Model if the transition weights would not be used as probabilities, although the data structure would be the same - and such with an HMM if such weights (eg. for outputs) would not be used as probabilities (with such a same data structure)
        #endregion

        //get closest distances of enemy
        bool isDoingDistributionOfFixedRelativeMovementCycles = true;
        Action AIActionNum = 0;
        if (!isDoingDistributionOfFixedRelativeMovementCycles)
        {
            AIActionNum = (Action)(prevGenStr[0]/* - read as a char?*/ - '0'); //with AI action with index 0
        }
        Vector3 moveVec = Vector3.zero;
        float deltaMovementScale = 1/* / Time.fixedDeltaTime * Time.deltaTime*/; //given 0.1f of movement on each FixedUpdate as done by the player movement, what would be the movement with Update that would be at least roughly equivalent speed 
        if (!isDoingDistributionOfFixedRelativeMovementCycles)
        {
            switch (AIActionNum)
            {
                case Action.Retreat:
                    //retreat generation behaviour
                    //move away from nearest enemy
                    moveVec = (shadowPos - currData.avgClosest2EnemyPosn).normalized * 0.1f * deltaMovementScale; //vector for delta in movement for the current Update - although would note how player would move via FixedUpdate
                                                                                                                  //quantize to closest movement angle and set animation
                    break;
                case Action.Attack:
                    //attack generation behaviour
                    //move towards nearest enemy
                    moveVec = (currData.avgClosest2EnemyPosn - shadowPos).normalized * 0.1f * deltaMovementScale;
                    //transform.position += new Vector3(moveVec.x, moveVec.y, 0);
                    break;
                case Action.Wander:
                    //wander generation behaviour
                    //move around in a 'random' manner but eg. humanly
                    //can just imitate already-existing wander behaviour as a current behaviour
                    //move with the Astar behaviour, initiating Astar seek towards an initialized Wander location each time that Wander behaviour would be just changed to, and ceasing such (of setting Wander location and Astar seek behaviour) when such Wander behaviour would be changed to something else
                    break;
            }
        }
        else //isDoingDistributionOfFixedRelativeMovementCycles
        {
            //determine moveVec based on the angle and such, with determining the movement vec based on such with weighting accordingly
            genBehaviourData moveData = SHMMDataOrdered3_currUsingCycle[SHMMDataOrdered3_cyclePosn.Item1].First;

            //Rotate CCW, as the training data with Vector2.SignedAngle as done in training would find the CCW angle
            Vector2 moveVecRelativeToMNPosComponent = Quaternion.Euler(0f, 0f, -moveData.movement_thisUpdate_CWAngleRelativeToMNPos) * (currData.avgClosest2EnemyPosn - shadowPos).normalized * moveData.movement_thisUpdate_Magnitude;
            Vector2 moveVecRelativeToSMPosComponent = Quaternion.Euler(0f, 0f, -moveData.movement_thisUpdate_CWAngleRelativeToSMPos) * (currData.medianEnemyPosn - shadowPos).normalized * moveData.movement_thisUpdate_Magnitude;

            //moveData.movement_thisUpdate_CWAngleRelativeToMNPos
            moveVec = (moveVecRelativeToMNPosComponent + moveVecRelativeToSMPosComponent) / 2;
            if (isUsing && getCurrMovementAngleAndMag)
            {
                Debug.Log("CWAngleRelativeToMNPos: " + moveData.movement_thisUpdate_CWAngleRelativeToMNPos + "; \r\nCWAngleRelativeToSMPos: " + moveData.movement_thisUpdate_CWAngleRelativeToSMPos + ";");
                Debug.Log("magnitude: " + moveData.movement_thisUpdate_Magnitude + "; \r\nmoveVec: " + moveVec);
                Debug.Log("moveData.isFiring_thisUpdate: " + moveData.isFiring_thisUpdate);
                Debug.Log("numPlayerAndAI matching updates of total of "+numPlayerAndAITotalTestingUpdates+": ");
                Debug.Log("Movement: "+numPlayerAndAIMovementMatchingUpdates+" ("+((int)((float)numPlayerAndAIMovementMatchingUpdates/numPlayerAndAITotalTestingUpdates*100))+"%); Shooting: "+numPlayerAndAIShootingMatchingUpdates+" ("+((int)((float)numPlayerAndAIShootingMatchingUpdates/numPlayerAndAITotalTestingUpdates*100))+"%); Both: "+numPlayerAndAIMovingAndShootingMatchingUpdates+" ("+((int)((float)numPlayerAndAIMovingAndShootingMatchingUpdates/numPlayerAndAITotalTestingUpdates * 100))+"%)");
                getCurrMovementAngleAndMag = false;
            }
            gizmoSpheresToDraw.Add(new gizmoSphereProperties() { color = Color.green, position = moveVec.normalized + transform.position, radius = 0.5f });

            isFiringThisUpdate = moveData.isFiring_thisUpdate;
        }

        #region MoveInnerInput-based code for getting closest movement point quantized to the closest movement angle, and setting the Shadow's animation for the corresponding direction
        //get closest movement point quantized to the closest movement angle
        //Get each of the 8 points, foreach through them? As one way ... Getting positions through sin and cos of each angle, times the radius
        Vector3 min_dist_degAnglePoint_Posn = new Vector3(0, 0);
        float min_dist_degAnglePoint_dist = 9 / transform.localScale.x/* - adding another GameObj_Radius length corresponding to the greater allowed input control acceptance range*/; //some impossibly large distance as default
        //int i_selected; //made into a public member variable instead, for accessibility of the animation index for the player to make use of said index for facing direction
        for (int degAngle = 0; degAngle < 360; degAngle += 45)
        {
            float degAngle_rad = degAngle * 2 * Mathf.PI / 360;

            //position of one of the 8 points
            Vector3 onePointPosition = (/*Vector3.zero *//* - edited from the OuterMovePart pos to 0, being basically used as a vector whose closest vector to moveVec would be used*//* +*/
                                  new Vector3(0f, 0.1f * Mathf.Sin(degAngle_rad), 0f) +
                                  new Vector3(0.1f * Mathf.Cos(degAngle_rad), 0f, 0f))
                                  ;
            float dist_degAnglePoint = (moveVec
                                  - onePointPosition).magnitude;
            if (dist_degAnglePoint < min_dist_degAnglePoint_dist)
            {
                min_dist_degAnglePoint_dist = dist_degAnglePoint;
                min_dist_degAnglePoint_Posn = onePointPosition; //does it copy? Well, it's passed by value according to someone, where such a person would have said that it's a structure
                dir_angleRad = degAngle_rad;
                dir_angleDeg = degAngle;
                dir_lastFacedAngleDeg = degAngle;
            }
        }
        i_selected = dir_angleDeg / 45; //corresponding index to the degAngle for animation setting

        //Check center of the <<move control><YKWIM>> as well
        //Vector3 centerPointPosition = OuterMovePart.OuterMovePart_Pos;
        //float dist_center = (moveVec
        //                          - centerPointPosition).magnitude;
        //if (dist_center < min_dist_degAnglePoint_dist)
        //{
        //    min_dist_degAnglePoint_dist = dist_center;
        //    min_dist_degAnglePoint_Posn = centerPointPosition; //does it copy? Well, it's passed by value according to someone, where such a person would have said that it's a structure
        //    dir_angleRad = -100f;
        //    dir_angleDeg = -100;
        //}
        //else //if the center point would not be the closest point
        //{
        //set animator animation to the index corresponding to the <<angle at which the nearest point would have been found><YKWIM>>

        //if firing on this update, discard animation based on movement - will be done based on shooting direction instead, if shooting
        if (!isFiringThisUpdate)
        {
            Animator animator = GetComponentInChildren<Animator>();
            if (animator.runtimeAnimatorController != shadowAnimations[i_selected]) //making this condition with noting of how some initialize method for the animator would be being called in this getData method
            {
                animator.runtimeAnimatorController = shadowAnimations[i_selected]; //set animation for the Shadow AI
            }
        }
        //}
        #endregion
        if(GetComponent<ShadowHealth>().isDead) //still, cease movement if the Shadow is dead
        {
            moveVec = Vector3.zero;
        }

        Vector3 moveVec_quantized = min_dist_degAnglePoint_Posn.normalized * /*0.1f * deltaMovementScale*/moveVec.magnitude;
        //movement
        if (!usedForLoggingTraining)
        {
            transform.position += new Vector3(moveVec_quantized.x, moveVec_quantized.y, 0); //noting of movement being done on Update instead of FixedUpdate with such Shadows, with noting of such a frame rate difference in movement, and such
        }
        else //use this for prediction
        {
            //if movements match
            //check with MoveInnerInput
            numPlayerAndAITotalTestingUpdates++;
            bool movementMatching = (dir_angleDeg == MoveInnerInput.dir_angleDeg || (moveVec_quantized == Vector3.zero && MoveInnerInput.dir_angleDeg == -100))/* if using mobile device inputs*/ || (player.GetComponent<TouchMove>().prevMoveDelta.normalized == moveVec_quantized.normalized); //check if the movement direction is matching or if there would be no direction
            bool shootingMatching = isFiringThisUpdate == FireShot.playerIsFiring;
            if (movementMatching)
            {
                numPlayerAndAIMovementMatchingUpdates++;
                if(shootingMatching) //if both are matching
                {
                    numPlayerAndAIMovingAndShootingMatchingUpdates++;
                }
            }
            if(shootingMatching)
            {
                numPlayerAndAIShootingMatchingUpdates++;
            }
        }

        //collision handling of movement
        if (transform.position != prevMovePosition && !isColliding)
            prevMoveDelta = transform.position - prevMovePosition;

        collisionsThisUpdate.Clear();
        collisionsThisUpdate.TrimExcess();
    }

    void DebuggingSHMM()
    {
        //create a List with the current weights
        //items_weights = new List<List<int>>();
        //foreach(var item in items)
        //{
        //    List<int> itemWeightList = new List<int>();
        //    items_weights.Add(itemWeightList);
        //    foreach(var item_weight in item.Value)
        //    {
        //        itemWeightList.Add(item_weight.Value); //weight of the MarkovUnit
        //    }
        //}
        items_weights_alltogether = new List<string>();

        bool isCycling_debug = false;
        bool isDistributionOfCycles_debug = false;
        bool isDistributionOfFixedRelativeMovementCycles_debug = true;
        if (isCycling_debug)
        {
            #region isCycling_debug
            foreach (var item in SHMMData_maintainOrder)
            {
                //List<int> itemWeightList = new List<int>();
                //items_weights.Add(itemWeightList);
                if (/*item.Key.items.Length >= 1*//* - there is a <<<state, or there are weights for that state><YKWIM>>?>*/item.Value.Count >= 1)
                {
                    string itemFeatureStr = item.Key;
                    EnemyDistance curreDistance = (EnemyDistance)(itemFeatureStr[0] - '0');
                    char maxSpeed = (char)(itemFeatureStr[1] - '0');

                    string eDistanceText = "";
                    switch (curreDistance)
                    {
                        case EnemyDistance.FAR:
                            eDistanceText = "FAR";
                            break;
                        case EnemyDistance.NEAR:
                            eDistanceText = "NEAR";
                            break;
                    }

                    string nearEnemyMaxSpeedText = "";
                    nearEnemyMaxSpeedText += ((char)(maxSpeed + '0'));

                    //MarkovUnit currItemMarkov = item.Key.items.Last(); //get the last item in the state, if there is one
                    foreach (var genItem in SHMMData_maintainOrder[itemFeatureStr]) //list generations and corresponding weights for the corresponding feature
                    {
                        string AIActionText = "";
                        string itemGenStr = genItem.Key; //AI action <<in string form><YKWIM>>
                        Action currAIAction = (Action)(itemGenStr[0] - '0'); //parsed AI action <<string><YKWIM>>
                        switch (currAIAction)
                        {
                            case Action.Attack:
                                AIActionText = "Attack";
                                break;
                            case Action.Retreat:
                                AIActionText = "Retreat";
                                break;
                            case Action.Wander:
                                AIActionText = "Wander";
                                break;
                        }
                        //TODO<< since 8/13/18, 11:11PM, with whatever would still <<apply that would be current as I would consider as current><YKWIM>>><YKWIM>>: <<make debug code for these><YKWIM>>
                        //and new version of <<this add as ><YKWIM>><<with DONE? progress as of 8/15/18, with ><YKWIM>>TODO<< as of 8/13/18, 11:13PM><YKWIM>>: items_weights_alltogether.Add("Unit "+ AIActionText + ", "/* +nearEnemyCountText+ ", "*/+nearEnemyMaxSpeedText+", "+ eDistanceText+": "); //MarkovUnit based on 

                        items_weights_alltogether.Add("With (" + eDistanceText + "," + nearEnemyMaxSpeedText + "), (" + AIActionText + ") w: "); //MarkovUnit based on 
                        int actionWeight = genItem.Value;
                        items_weights_alltogether.Add(actionWeight.ToString());
                    }
                }
                else
                {
                    items_weights_alltogether.Add("empty SHMM");
                }
            }
            #endregion
        }
        else if(isDistributionOfCycles_debug)
        {
            #region isDistributionOfCycles_debug
            foreach (var item in SHMMData_ofmaintainOrderCycles)
            {
                //List<int> itemWeightList = new List<int>();
                //items_weights.Add(itemWeightList);
                if (/*item.Key.items.Length >= 1*//* - there is a <<<state, or there are weights for that state><YKWIM>>?>*/item.Value.Count >= 1)
                {
                    string itemFeatureStr = item.Key;
                    EnemyDistance curreDistance = (EnemyDistance)(itemFeatureStr[0] - '0');
                    char maxSpeed = (char)(itemFeatureStr[1] - '0');

                    string eDistanceText = "";
                    switch (curreDistance)
                    {
                        case EnemyDistance.FAR:
                            eDistanceText = "FAR";
                            break;
                        case EnemyDistance.NEAR:
                            eDistanceText = "NEAR";
                            break;
                    }

                    string nearEnemyMaxSpeedText = "";
                    nearEnemyMaxSpeedText += ((char)(maxSpeed + '0'));

                    //MarkovUnit currItemMarkov = item.Key.items.Last(); //get the last item in the state, if there is one
                    foreach (var genCycleItem in SHMMData_ofmaintainOrderCycles[itemFeatureStr])
                    {
                        string genCycleText = "genCycle for ("+eDistanceText+", "+ nearEnemyMaxSpeedText +"): ";
                        items_weights_alltogether.Add(genCycleText);

                        foreach (var genItem in genCycleItem) //list generations and corresponding weights for the corresponding feature
                        {
                            string AIActionText = "";
                            string itemGenStr = genItem.Key; //AI action <<in string form><YKWIM>>
                            Action currAIAction = (Action)(itemGenStr[0] - '0'); //parsed AI action <<string><YKWIM>>
                            switch (currAIAction)
                            {
                                case Action.Attack:
                                    AIActionText = "Attack";
                                    break;
                                case Action.Retreat:
                                    AIActionText = "Retreat";
                                    break;
                                case Action.Wander:
                                    AIActionText = "Wander";
                                    break;
                            }
                            //TODO<< since 8/13/18, 11:11PM, with whatever would still <<apply that would be current as I would consider as current><YKWIM>>><YKWIM>>: <<make debug code for these><YKWIM>>
                            //and new version of <<this add as ><YKWIM>><<with DONE? progress as of 8/15/18, with ><YKWIM>>TODO<< as of 8/13/18, 11:13PM><YKWIM>>: items_weights_alltogether.Add("Unit "+ AIActionText + ", "/* +nearEnemyCountText+ ", "*/+nearEnemyMaxSpeedText+", "+ eDistanceText+": "); //MarkovUnit based on 

                            int actionWeight = genItem.Value;
                            items_weights_alltogether.Add("With (" + AIActionText + ") w: "+actionWeight.ToString()); //MarkovUnit based on 
                        }
                    }
                }
                else
                {
                    items_weights_alltogether.Add("empty SHMM");
                }
            }
            #endregion
        }
        else if (isDistributionOfFixedRelativeMovementCycles_debug)
        {
            #region isDistributionOfFixedRelativeMovementCycles
            int item_count = 0;
            foreach (var genItem in SHMMDataOrdered3_currUsingCycle) //list generations and corresponding weights for the corresponding feature
            {
                string AIActionText = "";
                string itemGenStr1 = "MN: " + genItem.First.movement_thisUpdate_CWAngleRelativeToMNPos + "; SM: " + genItem.First.movement_thisUpdate_CWAngleRelativeToSMPos + "; mag: " + genItem.First.movement_thisUpdate_Magnitude + "; "; //AI action <<in string form><YKWIM>>
                string itemGenStr2 = "w: " + genItem.Second + "; shoot: " + genItem.First.isFiring_thisUpdate;
                                                                                                                                                                                    //TODO<< since 8/13/18, 11:11PM, with whatever would still <<apply that would be current as I would consider as current><YKWIM>>><YKWIM>>: <<make debug code for these><YKWIM>>
                                                                                                                                                                                    //and new version of <<this add as ><YKWIM>><<with DONE? progress as of 8/15/18, with ><YKWIM>>TODO<< as of 8/13/18, 11:13PM><YKWIM>>: items_weights_alltogether.Add("Unit "+ AIActionText + ", "/* +nearEnemyCountText+ ", "*/+nearEnemyMaxSpeedText+", "+ eDistanceText+": "); //MarkovUnit based on 

                //int actionWeight = genItem.Value;
                items_weights_alltogether.Add("With: (" + itemGenStr1); //MarkovUnit based on 
                items_weights_alltogether.Add(itemGenStr2+")");
            }

            //foreach (var item in SHMMDataOrdered3_ofFixedLengthCycles)
            //{
            //    if(item_count > 20) //stop after item_count would reach 20
            //    {
            //        break;
            //    }
            //KeyValuePair<string, List<List<Pair<genMovementData, float>>>> item = new KeyValuePair<string, List<List<Pair<genMovementData, float>>>>();
            //List<int> itemWeightList = new List<int>();
            //items_weights.Add(itemWeightList);
            //if (/*item.Key.items.Length >= 1*//* - there is a <<<state, or there are weights for that state><YKWIM>>?>*/item.Value.Count >= 1)
            //    {
            //        string itemFeatureStr = item.Key;
            //        EnemyDistance curreDistance = (EnemyDistance)(itemFeatureStr[0] - '0');
            //        char maxSpeed = (char)(itemFeatureStr[1] - '0');
            //        string relativeMovement = itemFeatureStr.Substring(2);

            //        string eDistanceText = "";
            //        switch (curreDistance)
            //        {
            //            case EnemyDistance.FAR:
            //                eDistanceText = "FAR";
            //                break;
            //            case EnemyDistance.NEAR:
            //                eDistanceText = "NEAR";
            //                break;
            //        }

            //        string nearEnemyMaxSpeedText = "";
            //        nearEnemyMaxSpeedText += ((char)(maxSpeed + '0'));

            //        //MarkovUnit currItemMarkov = item.Key.items.Last(); //get the last item in the state, if there is one
            //        foreach (var genCycleItem in SHMMDataOrdered3_ofFixedLengthCycles[itemFeatureStr])
            //        {
            //            string genCycleText = "genCycle for (" + eDistanceText + ", " + nearEnemyMaxSpeedText + ", "+relativeMovement+"): ";
            //            items_weights_alltogether.Add(genCycleText);

            //            foreach (var genItem in genCycleItem) //list generations and corresponding weights for the corresponding feature
            //            {
            //                string AIActionText = "";
            //                string itemGenStr = "MN: "+genItem.First.movement_thisUpdate_CWAngleRelativeToMNPos+"; SM: "+genItem.First.movement_thisUpdate_CWAngleRelativeToSMPos+"; mag: "+genItem.First.movement_thisUpdate_Magnitude+"; w: "+genItem.Second; //AI action <<in string form><YKWIM>>
            //                //Action currAIAction = (Action)(itemGenStr[0] - '0'); //parsed AI action <<string><YKWIM>>
            //                //switch (currAIAction)
            //                //{
            //                //    case Action.Attack:
            //                //        AIActionText = "Attack";
            //                //        break;
            //                //    case Action.Retreat:
            //                //        AIActionText = "Retreat";
            //                //        break;
            //                //    case Action.Wander:
            //                //        AIActionText = "Wander";
            //                //        break;
            //                //}
            //                //TODO<< since 8/13/18, 11:11PM, with whatever would still <<apply that would be current as I would consider as current><YKWIM>>><YKWIM>>: <<make debug code for these><YKWIM>>
            //                //and new version of <<this add as ><YKWIM>><<with DONE? progress as of 8/15/18, with ><YKWIM>>TODO<< as of 8/13/18, 11:13PM><YKWIM>>: items_weights_alltogether.Add("Unit "+ AIActionText + ", "/* +nearEnemyCountText+ ", "*/+nearEnemyMaxSpeedText+", "+ eDistanceText+": "); //MarkovUnit based on 

            //                //int actionWeight = genItem.Value;
            //                items_weights_alltogether.Add("With (" + itemGenStr + ")"); //MarkovUnit based on 
            //            }
            //        }
            //    }
            //    else
            //    {
            //        items_weights_alltogether.Add("empty SHMM");
            //    }
            //    item_count++;
            //}
            #endregion
        }
        else
        {
            #region isDistribution
            foreach (var item in SHMMData)
            {
                //List<int> itemWeightList = new List<int>();
                //items_weights.Add(itemWeightList);
                if (/*item.Key.items.Length >= 1*//* - there is a <<<state, or there are weights for that state><YKWIM>>?>*/item.Value.Count >= 1)
                {
                    string itemFeatureStr = item.Key;
                    EnemyDistance curreDistance = (EnemyDistance)(itemFeatureStr[0] - '0');
                    char maxSpeed = (char)(itemFeatureStr[1] - '0');

                    string eDistanceText = "";
                    switch (curreDistance)
                    {
                        case EnemyDistance.FAR:
                            eDistanceText = "FAR";
                            break;
                        case EnemyDistance.NEAR:
                            eDistanceText = "NEAR";
                            break;
                    }

                    string nearEnemyMaxSpeedText = "";
                    nearEnemyMaxSpeedText += ((char)(maxSpeed + '0'));

                    //MarkovUnit currItemMarkov = item.Key.items.Last(); //get the last item in the state, if there is one
                    foreach (var genItem in SHMMData[itemFeatureStr]) //list generations and corresponding weights for the corresponding feature
                    {
                        string AIActionText = "";
                        string itemGenStr = genItem.Key; //AI action <<in string form><YKWIM>>
                        Action currAIAction = (Action)(itemGenStr[0] - '0'); //parsed AI action <<string><YKWIM>>
                        switch (currAIAction)
                        {
                            case Action.Attack:
                                AIActionText = "Attack";
                                break;
                            case Action.Retreat:
                                AIActionText = "Retreat";
                                break;
                            case Action.Wander:
                                AIActionText = "Wander";
                                break;
                        }
                        //TODO<< since 8/13/18, 11:11PM, with whatever would still <<apply that would be current as I would consider as current><YKWIM>>><YKWIM>>: <<make debug code for these><YKWIM>>
                        //and new version of <<this add as ><YKWIM>><<with DONE? progress as of 8/15/18, with ><YKWIM>>TODO<< as of 8/13/18, 11:13PM><YKWIM>>: items_weights_alltogether.Add("Unit "+ AIActionText + ", "/* +nearEnemyCountText+ ", "*/+nearEnemyMaxSpeedText+", "+ eDistanceText+": "); //MarkovUnit based on 

                        items_weights_alltogether.Add("With (" + eDistanceText + "," + nearEnemyMaxSpeedText + "), (" + AIActionText + ") w: "); //MarkovUnit based on 
                        int actionWeight = genItem.Value;
                        items_weights_alltogether.Add(actionWeight.ToString());
                    }
                }
                else
                {
                    items_weights_alltogether.Add("empty SHMM");
                }
            }
            #endregion
        }
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        prevMovePosition = transform.position; //used at least for collision handling


        if ((Input.GetKeyDown("u")/* || toggleTrainingAndUsing*/) && !usedForLoggingTraining) //toggle training and using - though this would not occur for the training logging Shadow
        {
            isUsing = !isUsing;
            isTraining = !isTraining;

            Debug.Log("Toggled so that " + (isUsing ? "isUsing" : "isTraining") + " is true.");
            toggleTrainingAndUsing = false;
            prevMovementDirTimer = prevMovementDirInterval; //reset movement dir //end of the period for the corresponding movement dir
        }
        if ((Input.GetKeyDown("y") || toggleTrainingAndUsing/* - where the on-screen button would be used for the logging Shadow*/) && usedForLoggingTraining) //toggle training and using
        {
            isUsing = !isUsing;
            isTraining = !isTraining;

            Debug.Log("Toggled so that " + (isUsing ? "isUsing" : "isTraining") + " is true for the logging Shadow.");
            toggleTrainingAndUsing = false;
            prevMovementDirTimer = prevMovementDirInterval; //reset movement dir //end of the period for the corresponding movement dir
        }

        //features as with <<ShadowAIMarkov><YKWIM>>
        //with: 
        //-adding weights for eg. features and\or such>
        //  -with noting of such <<with isTraining><YKWIM>>
        //-using such for behaviours
        //  -with noting of such <<with isUsing><YKWIM>>
        //
        if (isTraining && !WaveManager.fadeScreenIsActive && !PlayerHealth.playerIsDead)
        {
            Training();
        }
        //else is being used and/or testing

        //if saving MarkovChain - save on the frame that "m" is <<first pressed><YKWIM>>
        if (Input.GetKeyDown("m"))
        {
            savingData = true;
        }

        if (Input.GetKeyDown(";"))
        {
            loadingData = true;
            resetCurrTrainingCycle_withLoadedDataThisUpdate = true;
            resetCurrUsingCycle_withLoadedDataThisUpdate = true;
        }
        if(Input.GetKeyDown("'") && usedForLoggingTraining/* - disabling such for what would be apart from the ShadowCharacter logging training at the moment*/)
        {
            getCurrMovementAngleAndMag = true;
        }

        //TODO <<with such and being DONE? at 8/25/18 ><YKWIM>><<at 7/9/18, 6:18PM><YKWIM>> of <<making save and load data as for the SHMM><YKWIM>>
        if (savingData && usedForLoggingTraining/* saving only the Shadow used for training*/) //<<set this><YKWIM>> to true for one data save
        {
            SaveData();
            Debug.Log("Saving data of the SHMM into serializable data");
        }
        if(savingMovementData && usedForLoggingTraining) //done automatically when a player dies
        {
            PlayerPrefs.SetInt("numPlayerAndAIMovementMatchingUpdates", numPlayerAndAIMovementMatchingUpdates);
            PlayerPrefs.SetInt("numPlayerAndAIShootingMatchingUpdates", numPlayerAndAIShootingMatchingUpdates);
            PlayerPrefs.SetInt("numPlayerAndAIMovingAndShootingMatchingUpdates", numPlayerAndAIMovingAndShootingMatchingUpdates);
            PlayerPrefs.SetInt("numPlayerAndAITotalTestingUpdates", numPlayerAndAITotalTestingUpdates);
        }
        
        if (loadingData)
        {
            //only load data <wrtxtl: from><rmtxth: for> a file if <wrtxtl: the file><rmtxth: it> exists
            if (File.Exists(SaveLoadSHMM.currentFilePath))
            {
                SerializableSaveDataSHMM data;
                data = LoadData();
                Debug.Log("Loading data of the SHMM from serializable data");
            SHMMData = data.AISHMM;
            SHMMData_maintainOrder = data.AISHMM_maintainOrder;
            SHMMData_ofmaintainOrderCycles = data.AISHMM_ofmaintainOrderCycles;
            SHMMDataOrdered3_ofFixedLengthCycles = data.AISHMMOrdered3_ofFixedLengthCycles;
            }
        }

        if (isUsing && !WaveManager.fadeScreenIsActive && !PlayerHealth.playerIsDead/* && !usedForLoggingTraining*//* preventing action if it would be the 'training' Shadow*/) //'action' mode as opposed to 'training'
        {
            Using();
        }

        //Debug stuff - with <<DONE? progress as of 8/15/18<< - with some further progress done since starting writing this curr. "<<DONE? progress...>...>" writing><YKWIM>>, with ><YKWIM>>TODO<< at 7/9/18, 6:22PM><YKWIM>><< of making such work for the SHMM><YKWIM>>
        //Dictionary<ChainState<MarkovUnit>, Dictionary<MarkovUnit, int>> items = AIData.items;

        if (WaveManager.DEBUG_ENABLED)
        {
            DebuggingSHMM();
        }
        if (!WaveManager.fadeScreenIsActive)
        {
            resetMovementDirTimerThisUpdate = false;
        }
    }

    void OnCollisionEnter2D(Collision2D c) //didn't realize the "2D" part of the name ... in doing this ... and such regarding collision ...
    {
        if (c.gameObject.CompareTag("Obstacle") && /*!collisionOccurredThisUpdate*/!collisionsThisUpdate.Contains(c))
        {
            //Debug.Log("Collision occurring");
            //isColliding = true;
            collisionsThisUpdate.Add(c);

            //test if no more intersection when reversing just x
            //thisRigidbody2D.MovePosition(thisRigidbody2D.position - new Vector2(prevMoveDelta.x, 0));
            thisBoxCollider2D.offset -= new Vector2(prevMoveDelta.x, 0); //set offset - with corresponding reversed position - for testing
            if (!thisBoxCollider2D.bounds.Intersects(c.collider.bounds))
            {
                thisBoxCollider2D.offset += new Vector2(prevMoveDelta.x, 0); //revert offset
                transform.position -= new Vector3(prevMoveDelta.x, 0, 0);/* //move Rigidbody instead*/
                //Debug.Log("Reversing x only");
                return;
            }
            else
            {
                thisBoxCollider2D.offset += new Vector2(prevMoveDelta.x, 0); //revert offset
            }
            //thisRigidbody2D.MovePosition(thisRigidbody2D.position + new Vector2(prevMoveDelta.x, 0));

            //test if no more collision\intersection when reversing just y
            //transform.position -= new Vector3(0, prevMoveDelta.y, 0);
            thisBoxCollider2D.offset -= new Vector2(0, prevMoveDelta.y); //set offset - with corresponding reversed position - for testing
            if (!thisBoxCollider2D.bounds.Intersects(c.collider.bounds))
            {
                thisBoxCollider2D.offset += new Vector2(0, prevMoveDelta.y); //revert offset
                //Debug.Log("Reversing y only");
                transform.position -= new Vector3(0, prevMoveDelta.y, 0); //move Rigidbody instead
                return;
            }

            //x and y reversals alone lead to collision; reverse both
            //Debug.Log("Reversing x and y");
            thisBoxCollider2D.offset -= new Vector2(prevMoveDelta.x, 0);
            //transform.position -= new Vector3(prevMoveDelta.x, 0, 0);
            //transform.position -= prevMoveDelta; //move in the opposite direction of the last moved direction

            //if still colliding despite all reversal of thisBoxCollider2D, set this to true
            if (thisBoxCollider2D.bounds.Intersects(c.collider.bounds))
            {
                isColliding = true;
            }
            //else// if !thisBoxCollider2D.bounds.Intersects(c.collider.bounds)
            //{
            //    thisBoxCollider2D.offset += new Vector2(prevMoveDelta.x, prevMoveDelta.y);
            //    thisRigidbody2D.MovePosition(thisRigidbody2D.position - new Vector2(prevMoveDelta.x, prevMoveDelta.y));
            //}
            thisBoxCollider2D.offset += new Vector2(prevMoveDelta.x, prevMoveDelta.y);
            //Debug.Log("still colliding-beforeMovePosition; thisRigidbody2D.position: " + thisRigidbody2D.position);
            transform.position -= new Vector3(prevMoveDelta.x, prevMoveDelta.y, 0)/*new Vector2(prevMoveDelta.x, prevMoveDelta.y)*/;
            //Debug.Log("still colliding; thisRigidbody2D.position: "+thisRigidbody2D.position+ "; new Vector2(prevMoveDelta.x, prevMoveDelta.y): "+new Vector2(prevMoveDelta.x, prevMoveDelta.y));
            //collisionOccurredThisUpdate = true;
        }
    }
    void OnCollisionStay2D(Collision2D c)
    {
        if (c.gameObject.CompareTag("Obstacle") && /*!collisionOccurredThisUpdate*/!collisionsThisUpdate.Contains(c))
        {
            //Debug.Log("Collision occurring");
            //isColliding = true;
            collisionsThisUpdate.Add(c);

            //test if no more intersection when reversing just x
            //thisRigidbody2D.MovePosition(thisRigidbody2D.position - new Vector2(prevMoveDelta.x, 0));
            thisBoxCollider2D.offset -= new Vector2(prevMoveDelta.x, 0); //set offset - with corresponding reversed position - for testing
            if (!thisBoxCollider2D.bounds.Intersects(c.collider.bounds))
            {
                thisBoxCollider2D.offset += new Vector2(prevMoveDelta.x, 0); //revert offset
                transform.position -= new Vector3(prevMoveDelta.x, 0, 0);/* //move Rigidbody instead*/
                //Debug.Log("Reversing x only");
                return;
            }
            else
            {
                thisBoxCollider2D.offset += new Vector2(prevMoveDelta.x, 0); //revert offset
            }
            //thisRigidbody2D.MovePosition(thisRigidbody2D.position + new Vector2(prevMoveDelta.x, 0));

            //test if no more collision\intersection when reversing just y
            //transform.position -= new Vector3(0, prevMoveDelta.y, 0);
            thisBoxCollider2D.offset -= new Vector2(0, prevMoveDelta.y); //set offset - with corresponding reversed position - for testing
            if (!thisBoxCollider2D.bounds.Intersects(c.collider.bounds))
            {
                thisBoxCollider2D.offset += new Vector2(0, prevMoveDelta.y); //revert offset
                //Debug.Log("Reversing y only");
                transform.position -= new Vector3(0, prevMoveDelta.y, 0); //move Rigidbody instead
                return;
            }

            //x and y reversals alone lead to collision; reverse both
            //Debug.Log("Reversing x and y");
            thisBoxCollider2D.offset -= new Vector2(prevMoveDelta.x, 0);
            //transform.position -= new Vector3(prevMoveDelta.x, 0, 0);
            //transform.position -= prevMoveDelta; //move in the opposite direction of the last moved direction

            //if still colliding despite all reversal of thisBoxCollider2D, set this to true
            if (thisBoxCollider2D.bounds.Intersects(c.collider.bounds))
            {
                isColliding = true;
            }
            //else// if !thisBoxCollider2D.bounds.Intersects(c.collider.bounds)
            //{
            //    thisBoxCollider2D.offset += new Vector2(prevMoveDelta.x, prevMoveDelta.y);
            //    thisRigidbody2D.MovePosition(thisRigidbody2D.position - new Vector2(prevMoveDelta.x, prevMoveDelta.y));
            //}
            thisBoxCollider2D.offset += new Vector2(prevMoveDelta.x, prevMoveDelta.y);
            //Debug.Log("still colliding-beforeMovePosition; thisRigidbody2D.position: " + thisRigidbody2D.position);
            transform.position -= new Vector3(prevMoveDelta.x, prevMoveDelta.y, 0)/*new Vector2(prevMoveDelta.x, prevMoveDelta.y)*/;
            //Debug.Log("still colliding; thisRigidbody2D.position: "+thisRigidbody2D.position+ "; new Vector2(prevMoveDelta.x, prevMoveDelta.y): "+new Vector2(prevMoveDelta.x, prevMoveDelta.y));
            //collisionOccurredThisUpdate = true;
        }
    }
    void OnCollisionExit2D(Collision2D c)
    {
        if (c.gameObject.CompareTag("Obstacle"))
        {
            isColliding = false; //allow movement once collision is exited
        }
    }

    //#if UNITY_EDITOR
    //    [System.NonSerialized]
    //    int gizmoHash = 0;

    //    [System.NonSerialized]
    //    float lastChangedTime = float.NegativeInfinity;

    //    protected static readonly Color GizmoColor = new Color(46.0f / 255, 104.0f / 255, 201.0f / 255);

    //    protected void OnDrawGizmos()
    //    {

    //        //base.OnDrawGizmos();
    //        /*if (alwaysDrawGizmos) */OnDrawGizmosInternal();
    //    }

    //    protected override void OnDrawGizmosSelected()
    //    {
    //        //base.OnDrawGizmosSelected();
    //        /*if (!alwaysDrawGizmos) */OnDrawGizmosInternal();
    //    }

    //    void OnDrawGizmosInternal()
    //    {
    //        var newGizmoHash = pickNextWaypointDist.GetHashCode() ^ slowdownDistance.GetHashCode() ^ endReachedDistance.GetHashCode();

    //        if (newGizmoHash != gizmoHash && gizmoHash != 0) lastChangedTime = Time.realtimeSinceStartup;
    //        gizmoHash = newGizmoHash;
    //        float alpha = alwaysDrawGizmos ? 1 : Mathf.SmoothStep(1, 0, (Time.realtimeSinceStartup - lastChangedTime - 5f) / 0.5f) * (UnityEditor.Selection.gameObjects.Length == 1 ? 1 : 0);

    //        if (alpha > 0)
    //        {
    //            // Make sure the scene view is repainted while the gizmos are visible
    //            if (!alwaysDrawGizmos) UnityEditor.SceneView.RepaintAll();
    //            Draw.Gizmos.Line(position, steeringTarget, GizmoColor * new Color(1, 1, 1, alpha));
    //            Gizmos.matrix = Matrix4x4.TRS(position, transform.rotation * (rotationIn2D ? Quaternion.Euler(-90, 0, 0) : Quaternion.identity), Vector3.one);
    //            Draw.Gizmos.CircleXZ(Vector3.zero, pickNextWaypointDist, GizmoColor * new Color(1, 1, 1, alpha));
    //            Draw.Gizmos.CircleXZ(Vector3.zero, slowdownDistance, Color.Lerp(GizmoColor, Color.red, 0.5f) * new Color(1, 1, 1, alpha));
    //            Draw.Gizmos.CircleXZ(Vector3.zero, endReachedDistance, Color.Lerp(GizmoColor, Color.red, 0.8f) * new Color(1, 1, 1, alpha));
    //        }
    //    }
    //#endif
#if UNITY_EDITOR
    protected void OnDrawGizmos()
    {
        if(!enableOnDrawGizmos)
        {
            return;
        }
        //base.OnDrawGizmos();
        /*if (alwaysDrawGizmos) */
        //OnDrawGizmosInternal();
        //while(gizmoSpheresToDraw.Count > 0)
        //{
        foreach (gizmoSphereProperties currSphereProperties in gizmoSpheresToDraw)
        {
            Gizmos.color = currSphereProperties.color;
            Gizmos.DrawSphere(currSphereProperties.position, currSphereProperties.radius);
        }
        //}
    }
#endif
}
